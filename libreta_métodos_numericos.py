# -*- coding: utf-8 -*-
"""Libreta Métodos numericos.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ixXSzfvdbhgKScBpWloi1gJYPjgB7OBA

# Libreta de Métodos Numéricos

---



La libreta interactiva cuenta con el contenido de la materia de 
métodos numéricos,
consistiendo en una versión condensada de la teoría en clase, imágenes y
recursos adicionales relevantes, y entre las explicaciones celdas
código para que se pueda resolver un problema con las condiciones que ingrese el
usuario con el método expuesto en la libreta. La libreta se puede abrir desde
cualquier navegador moderno sin necesidad de instalar nada en la computadora
de la persona.

La libreta se divide en apartados relacionados con la resolución de los métodos
numéricos. Los apartados son los siguientes:



*   [Interpolación](#section2)
*   [Ecuaciones no lineales.](#section3)
*   [Ecuaciones lineales.](#section4)
*   [Mínimos Cuadrados.](#section5)
*   [Integración.](#section6)
*   [Ecuaciones Diferenciales Ordinarias. ](#section7)

<a name="section2"></a>
# Interpolación Numérica:

## ¿Qué es?

La interpolación es el método por el que podemos obtener nuevos puntos a partir de un conjunto de datos previos, ajustándolos a una función o a una tabla de valores. Los puntos que se interpolen deben de estar en el intervalo del que se tienen los datos de los extremos. Su importancia radica en que muchos de los métodos numéricos que se implementan tienen sus bases en la interpolación.

## ¿Cuál es su solución?

La interpolación de datos se soluciona cuando determinamos el polinomio de la función que se ajusta a los puntos, para esto existen múltiples métodos como:
   * Interpolación Lineal
   * Newton hacia Adelante
   * Newton hacia Atrás
   * Newton con Diferencias Divididas
   * Lagrange
"""

# Commented out IPython magic to ensure Python compatibility.
# #@title Correr esta celda para poder comenzar a utilizar la libreta
# %%capture
# from google.colab import output
# !pip install ipympl
# %matplotlib widget
# import numpy as np
# import matplotlib.pyplot as plt
# import sys
# from scipy.interpolate import lagrange
# from IPython.display import Math,display
# 
# %matplotlib inline
# plt.style.use('seaborn-colorblind')
# plt.rcParams['figure.figsize'] = 8.4, 6.8

"""## Lineal <a name="paragraph1"></a> :

### ¿Cómo funciona?

La interpolación lineal trata de unir dos puntos con una línea recta, usando el concepto de la primera derivada de una función. Su fórmula es $g(x) = \dfrac{f(b)-f(a)}{b-a} (x-a) + f(a)$

Cuanto menor sea el intervalo entre los datos, mejor será el resultado de la aproximación de la función de la recta.
### ¿Cómo se puede usar?

Para usar este método, hay que ejecutar la **celda** de código siguiente e ingresar dos valores $a$ y $b$, posteriormente hay que ingresar los valores encontrados en $f(a)$ y $f(b)$ y por último el valor de $x$ que se quiere interpolar. Debajo de la **celda** actual de código se encuentra una celda para poder graficar el resultado de la interpolación.
"""

#@title Calculadora Interpolación Lineal
try:
  arr_x_lineal = [] 
  arr_x_lineal.append(float(input("Ingrese el valor de a: ")))
  arr_x_lineal.append(float(input("Ingrese el valor de b: ")))
  arr_x_lineal = np.array(arr_x_lineal)

  arr_y_lineal = []
  arr_y_lineal.append(float(input("\nIngrese el valor de f(a): ")))
  arr_y_lineal.append(float(input("Ingrese el valor de (b): ")))
  arr_y_lineal = np.array(arr_y_lineal)

  x_interpolar_lineal = float(input("\nIngrese el valor de x a interpolar en g(x): "))

  if(x_interpolar_lineal>arr_x_lineal[1] or x_interpolar_lineal<arr_x_lineal[0]):
    output.clear()
    print("\nEl valor de x ingresado no se encuentra dentro del rango")
    raise SystemExit

  interp_lineal = np.interp(x_interpolar_lineal, arr_x_lineal, arr_y_lineal)
  print("\nEl valor de la interpolación lineal de g(x) es: ", interp_lineal)
  print("Generando gráfica de la interpolación")
  fig1,ax1 = plt.subplots()
  plot_x_lineal = np.linspace(arr_x_lineal[0], arr_x_lineal[1], 2, endpoint=True)
  plot_y_lineal = np.linspace(arr_y_lineal[0], arr_y_lineal[1], 2, endpoint=True)
  ax1.plot(plot_x_lineal,plot_y_lineal,'bo') #blue o
  ax1.plot(x_interpolar_lineal, interp_lineal, 'ro') # red o
  ax1.plot(plot_x_lineal,plot_y_lineal, color='green', linestyle='dashed',linewidth=1.2)
  ax1.set_title('Interpolación lineal', fontsize=18)
  ax1.set_xlabel('x', fontsize=15)
  ax1.set_ylabel('g(x)', fontsize=15)
  fig1.show();
#except extrapolar:
  #print("El valor de x ingresado no se encuentra dentro del rango")    
except:
  #output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")

"""## Newton hacia adelante:

### ¿Cómo funciona?

Para evaluar una fórmula de interpolación de Newton hacia Adelante son necesarios:


1.   Tablas de coeficientes hacia adelante
2.   coeficiente binomiales

$\triangle ^{k}\imath =\triangle ^{k-1}fi+1 - \triangle ^{k-1}fi$ 

diferencia hacia adelante de orden k 

Tablas de diferencias

$i  ~~~~~ \triangle ^{0}fi~~~~~ \triangle ^{1}fi ~~~~~\triangle ^{2}fi~~~~~ \triangle ^{3}fi ~~~~~\triangle ^{4}fi$

$0  ~~~~~ \triangle ^{0}f0~~~~~ \triangle ^{1}f0~~~~~\triangle ^{2}f0~~~~~ \triangle ^{3}f0 ~~~~~$

$1  ~~~~~ \triangle ^{0}f1~~~~~ \triangle ^{1}f1~~~~~\triangle ^{2}f1$

$2  ~~~~~ \triangle ^{0}f2~~~~~ \triangle ^{1}f2$

$3  ~~~~~ \triangle ^{0}f3$

La formula que se utiliza para obtener el valor a interpolar es la siguiente:

$g(x) = yi \left(\begin{array}{c}s\\ 0\end{array}\right) + \triangle'f(xi)\left(\begin{array}{c}s\\ 1\end{array}\right) + \triangle^{2}f(xi)(\frac{s(s-1)}{2!}) + ...$

### ¿Cómo se puede usar?

Al ejecutarse la celda consecuente la calculadora pregunta al usuario el numero de datos, posteriormente se debe ingresar los valores para $xi$ y para $f(xi)$, después se muestra la tabla de diferencias y finalmente se pide al usuario ingresar el valor para el cual desea interpolar
"""

#@title Calculadora Newton hacia adelante
try:
  def u_cal(u, n): 
    
      temp = u; 
      for i in range(1, n): 
          temp = temp * (u - i); 
      return temp; 
    
  def fact(n): 
      f = 1; 
      for i in range(2, n + 1): 
          f *= i; 
      return f; 

  n_nwt_delante=int(input("Ingrese el número de datos: "))
  arr_x_nwt_delante = []
  arr_y_nwt_delante = []
  for a in range(1,n_nwt_delante+1):
      arr_x_nwt_delante.append(float(input("Ingrese el valor de x"+str(a)+": ")))
      arr_y_nwt_delante.append(float(input("Ingrese el valor de y"+str(a)+": ")))

  dif_nwt_delante = arr_x_nwt_delante[1] - arr_x_nwt_delante[0]
  dif_temp_nwt_delante = 0
  check_nwt_delante = True
  for x_nwt_delante in range(1, len(arr_x_nwt_delante)-1):
      dif_temp_nwt_delante = arr_x_nwt_delante[x_nwt_delante+1] - arr_x_nwt_delante[x_nwt_delante]
      if dif_temp_nwt_delante != dif_nwt_delante:
          print("Los contenidos no son uniformes")
          check_nwt_delante = False
          break
      else:
          arr_x_nwt_delante = np.asarray(arr_x_nwt_delante)
          arr_y_nwt_delante=np.asarray(arr_y_nwt_delante)
          x_nwt_delante = arr_x_nwt_delante
          y_nwt_delante = [[0 for i in range(n_nwt_delante)] for j in range(n_nwt_delante)]

          for a in range(len(arr_y_nwt_delante)):
              y_nwt_delante[a][0] = arr_y_nwt_delante[a]

          for i in range(1, n_nwt_delante): 
              for j in range(n_nwt_delante - i): 
                  y_nwt_delante[j][i] = y_nwt_delante[j + 1][i - 1] - y_nwt_delante[j][i - 1]; 

          print("Imprimiendo coeficientes:\n")
          for i in range(n_nwt_delante): 
              print(x_nwt_delante[i], end = "\t") 
              for j in range(n_nwt_delante - i): 
                  print(y_nwt_delante[i][j], end = "\t"); 
              print("") 
          x_interp_nwt_delante = float(input("\nIngrese el valor a interpolar en g(x): "))
          if(x_interp_nwt_delante>arr_x_nwt_delante[1] or x_interp_nwt_delante<arr_x_nwt_delante[0]):
            output.clear()
            print("\nEl valor de x ingresado no se encuentra dentro del rango")
            raise SystemExit
          
          sum_nwt_delante = y_nwt_delante[0][0]; 
          u = (x_interp_nwt_delante - x_nwt_delante[0]) / (x_nwt_delante[1] - x_nwt_delante[0]); 
          for i in range(1,n_nwt_delante): 
              sum_nwt_delante = sum_nwt_delante + (u_cal(u, i) * y_nwt_delante[0][i]) / fact(i); 

  print("\nEl valor de la interpolación de Newton hacia adelante en g(x) es: " + str(sum_nwt_delante))
  if check_nwt_delante:
      #plotear
      print("Generando gráfica de la interpolación")
      fig2,ax2 = plt.subplots()
      ax2.plot(arr_x_nwt_delante,arr_y_nwt_delante,'bo') #blue o
      ax2.plot(x_interp_nwt_delante, sum_nwt_delante, 'ro') # red o
      ax2.plot(arr_x_nwt_delante,arr_y_nwt_delante, color='green', linestyle='dashed',linewidth=1.2)
      ax2.set_title('Newton hacia adelante', fontsize=18)
      ax2.set_xlabel('x', fontsize=15)
      ax2.set_ylabel('g(x)', fontsize=15)
      fig2.show();
  else:
      print("No se puede generar la gráfica")
except:
  #output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")

"""## Newton hacia atrás

### ¿Cómo funciona?
Este método tiene 2 cambios con respecto a Newton hacia adelante y son las siguientes:

$\triangledown ^{k-1}f(x_{i+1}) =\triangledown ^{k}f(x_{i+1}) - \triangledown ^{k}f(x_{i})$



$g(x)= \sum_{k=0}^{n-1} \triangle^{k} f(x_{i+1}) \prod_{j=0}^k\frac{(s+j)}{(j+1)!}$


### ¿Cómo se puede utilizar?

Al ejecutarse la celda consecuente la calculadora pregunta al usuario el numero de datos, posteriormente se debe ingresar los valores para $xi$ y para $f(xi)$, después se muestra la tabla de coeficientes y finalmente se pide al usuario ingresar el valor para el cual desea interpolar
"""

#@title Calculadora Newton hacia atras
try:
  def u_cal(u, n):

      temp = u
      for i in range(1, n):
          temp = temp * (u + i)
      return temp


  def fact(n):
      f = 1
      for i in range(2, n + 1):
          f *= i
      return f


  n_nwt_atras = int(input("Ingrese el número de datos: "))
  arr_x_nwt_atras = []
  arr_y_nwt_atras = []
  for a in range(1, n_nwt_atras+1):
      arr_x_nwt_atras.append(float(input("Ingrese el valor de x"+str(a)+": ")))
      arr_y_nwt_atras.append(float(input("Ingrese el valor de y"+str(a)+": ")))

  dif_nwt_atras = arr_x_nwt_atras[1] - arr_x_nwt_atras[0]
  dif_temp_nwt_atras = 0
  check_nwt_atras = True
  for x_nwt_atras in range(1, len(arr_x_nwt_atras)-1):
      dif_temp_nwt_atras = arr_x_nwt_atras[x_nwt_atras+1] - arr_x_nwt_atras[x_nwt_atras]
      if dif_temp_nwt_atras != dif_nwt_atras:
          print("Los contenidos no son uniformes")
          check_nwt_atras = False
          break
          sys.exit
  arr_x_nwt_atras = np.asarray(arr_x_nwt_atras)
  arr_y_nwt_atras = np.asarray(arr_y_nwt_atras)
  x_nwt_atras = arr_x_nwt_atras
  y_nwt_atras = [[0 for i in range(n_nwt_atras)] for j in range(n_nwt_atras)]

  for a in range(len(arr_y_nwt_atras)):
      y_nwt_atras[a][0] = arr_y_nwt_atras[a]

  for i in range(1, n_nwt_atras):
      for j in range(n_nwt_atras-1, i-1, -1):
          y_nwt_atras[j][i] = y_nwt_atras[j][i - 1] - y_nwt_atras[j - 1][i - 1]

  print("Imprimiendo coeficientes:\n")
  for i in range(0, n_nwt_atras):
      print(x_nwt_atras[i], end="\t")
      for j in range(0, i+1):
          print(y_nwt_atras[i][j], end="\t")
      print("")
  x_interp_nwt_atras = float(input("\nIngrese el valor a interpolar en g(x): "))
  if(x_interp_nwt_atras>arr_x_nwt_atras[1] or x_interp_nwt_atras<arr_x_nwt_atras[0]):
            output.clear()
            print("\nEl valor de x ingresado no se encuentra dentro del rango")
            raise SystemExit
  sum_nwt_atras = y_nwt_atras[n_nwt_atras-1][0]
  u = (x_interp_nwt_atras - x_nwt_atras[n_nwt_atras-1]) / (x_nwt_atras[1] - x_nwt_atras[0])
  for i in range(1, n_nwt_atras):
      sum_nwt_atras = sum_nwt_atras + (u_cal(u, i) * y_nwt_atras[n_nwt_atras-1][i]) / fact(i)

  print("\nEl valor de la interpolación de Newton hacia atrás en g(x) es: " + str(sum_nwt_atras))
  if check_nwt_atras:
      #plotear
      print("Generando gráfica de la interpolación")
      fig3,ax3 = plt.subplots()
      ax3.plot(arr_x_nwt_atras, arr_y_nwt_atras, 'bo')  # blue o
      ax3.plot(x_interp_nwt_atras, sum_nwt_atras, 'ro')  # red o
      ax3.plot(arr_x_nwt_atras, arr_y_nwt_atras, color='green',
              linestyle='dashed', linewidth=1.2)
      ax3.set_title('Newton hacia atrás', fontsize=18)
      ax3.set_xlabel('x', fontsize=15)
      ax3.set_ylabel('g(x)', fontsize=15)
      fig3.show();
  else:
      print("No se puede generar la gráfica")
except:
  #output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")

"""## Newton con Diferencias Divididas

###¿cómo funciona?
Este método se aplica cuando los intervalos son no uniformes y la formula que se utiliza es la siguiente:


$g(x)= D^{0} + D^{1}(x-x_1) + D^{2}(x-x_1)(x-x_2) +D^{3}(x-x_1)(x-x_2)(x-x_3)$




1.   Se requiere $i+1$ puntos de $y$
2.   La resta de dos diferecnias de tipo $i-1$, es el numerador
3.   La resta de dos valores no comunes en el numerados, es el denominador

###¿cómo se puede utilizar?

Al ejecutarse la celda consecuente la calculadora pregunta al usuario el numero de datos, posteriormente se debe ingresar los valores para  xi  y para  f(xi) , después se muestra la tabla de diferencias y finalmente se pide al usuario ingresar el valor para el cual desea interpolar
"""

#@title Calculadora Newton con Diferencias Divididas
try:
  def proterm(i, value, x):
      pro = 1
      for j in range(i):
          pro = pro * (value - x[j])
      return pro


  def tablaDiferencias(x, y, n):

      for i in range(1, n):
          for j in range(n - i):
              y[j][i] = ((y[j][i - 1] - y[j + 1][i - 1]) /
                        (x[j] - x[i + j]))
      return y


  def aplicarFormula(value, x, y, n):

      sum = y[0][0]

      for i in range(1, n):
          sum = sum + (proterm(i, value, x) * y[0][i])

      return sum


  def imprimirTabla(y, n):

      for i in range(n):
          for j in range(n - i):
              print(round(y[i][j], 4), "\t",
                    end=" ")

          print("")


  n_nwt_dd = int(input("Ingrese el número de datos: "))
  arr_x_nwt_dd = []
  arr_y_nwt_dd = []
  for a in range(1, n_nwt_dd+1):
      arr_x_nwt_dd.append(float(input("Ingrese el valor de x"+str(a)+": ")))
      arr_y_nwt_dd.append(float(input("Ingrese el valor de y"+str(a)+": ")))

  arr_x_nwt_dd = np.asarray(arr_x_nwt_dd)
  arr_y_nwt_dd = np.asarray(arr_y_nwt_dd)
  x_nwt_dd = arr_x_nwt_dd
  y_nwt_dd = [[0 for i in range(n_nwt_dd)] for j in range(n_nwt_dd)]

  for a in range(len(arr_y_nwt_dd)):
      y_nwt_dd[a][0] = arr_y_nwt_dd[a]

  y_nwt_dd = tablaDiferencias(x_nwt_dd, y_nwt_dd, n_nwt_dd)

  print("Imprimiendo tabla de diferencias:\n")
  imprimirTabla(y_nwt_dd, n_nwt_dd)

  x_interp_nwt_dd = float(input("\nIngrese el valor a interpolar en g(x): "))
  if(x_interp_nwt_dd>arr_x_nwt_dd[1] or x_interp_nwt_dd<arr_x_nwt_dd[0]):
            output.clear()
            print("\nEl valor de x ingresado no se encuentra dentro del rango")
            raise SystemExit

  interp_nwt_dd = aplicarFormula(x_interp_nwt_dd, x_nwt_dd, y_nwt_dd, n_nwt_dd)
  print("\nEl valor de la interpolación de Newton con Diferencias Divididas en g(x) es: " + str(interp_nwt_dd))
  #plotear
  print("Generando gráfica de la interpolación")
  fig4,ax4 = plt.subplots()
  ax4.plot(arr_x_nwt_dd, arr_y_nwt_dd, 'bo')  # blue o
  ax4.plot(x_interp_nwt_dd, interp_nwt_dd, 'ro')  # red o
  ax4.plot(arr_x_nwt_dd, arr_y_nwt_dd, color='green', linestyle='dashed', linewidth=1.2)
  ax4.set_title('Newton con Diferencias Divididas', fontsize=18)
  ax4.set_xlabel('x', fontsize=15)
  ax4.set_ylabel('g(x)', fontsize=15)
  fig4.show();
except:
  #output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")

"""## Lagrange

###¿Cómo funciona?
El método de Lagrange sirve tanto para intervalos uniformes como no uniformes

Su formula se define de la siguiente manera,
$$g(x) =  y_1 \frac{(x-x_2)(x-x_3)(x-x_4)}{(x_1-x_2)(x_1-x_3)(x_1-x_4)} + 
y_2 \frac{(x-x_1)(x-x_3)(x-x_4)}{(x_2-x_1)(x_2-x_3)(x_2-x_4)} +
y_3 \frac{(x-x_1)(x-x_2)(x-x_4)}{(x_3-x_1)(x_3-x_2)(x_3-x_4)} +
y_4 \frac{(x-x_1)(x-x_2)(x-x_3)}{(x_4-x_1)(x_4-x_2)(x_4-x_3)} + y_n$$

###¿cómo se puede utilizar?

Al ejecutarse la celda consecuente la calculadora pregunta al usuario el numero de datos, posteriormente se debe ingresar los valores para  xi  y para  f(xi) , finalmente se pide al usuario ingresar el valor para el cual desea interpolar y se muestra su resultado
"""

#@title Calculadora Lagrange
try:
  n_lagrange = int(input("Ingrese el número de datos: "))
  arr_x_lagrange = []
  arr_y_lagrange = []
  for a in range(1, n_lagrange+1):
      arr_x_lagrange.append(float(input("Ingrese el valor de x"+str(a)+": ")))
      arr_y_lagrange.append(float(input("Ingrese el valor de y"+str(a)+": ")))

  arr_x_lagrange = np.asarray(arr_x_lagrange)
  arr_y_lagrange = np.asarray(arr_y_lagrange)
  x_lagrange = arr_x_lagrange
  y_lagrange = arr_y_lagrange
  x_interp_lagrange = float(input("\nIngrese el valor a interpolar en g(x): "))
  if(x_interp_lagrange>arr_x_lagrange[1] or x_interp_lagrange<arr_x_lagrange[0]):
            output.clear()
            print("\nEl valor de x ingresado no se encuentra dentro del rango")
            raise SystemExit

  poly = lagrange(x_lagrange, y_lagrange)
  print(poly)
  y_interp_lagrange = poly(x_interp_lagrange)

  print("\nEl valor de la interpolación de Lagrange en g(x) es: ", y_interp_lagrange)
  

  # plotear
  print("Generando gráfica de la interpolación")
  fig5,ax5 = plt.subplots()
  ax5.plot(arr_x_lagrange, arr_y_lagrange, 'bo')  # blue o
  ax5.plot(x_interp_lagrange, y_interp_lagrange, 'ro')  # red o
  ax5.plot(arr_x_lagrange, arr_y_lagrange, color='green',
          linestyle='dashed', linewidth=1.2)
  ax5.set_title('Lagrange', fontsize=18)
  ax5.set_xlabel('x', fontsize=15)
  ax5.set_ylabel('g(x)', fontsize=15)
  fig5.show()
except:
  #output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")

"""## Interpolar de manera general

###¿Cómo se puede utilizar?
Esta calculadora no trabaja con un metodo especifco, el usuario ingresa su tabla de valores y el programa debe encontrar el metodo mas apropiado para trabajar con la informacion obtenida previamente
"""

#@title Calculadora para interpolar de manera general
try:
  def u_cal(u, n): 
    
      temp = u; 
      for i in range(1, n): 
          temp = temp * (u - i); 
      return temp; 
    
  def fact(n): 
      f = 1; 
      for i in range(2, n + 1): 
          f *= i; 
      return f; 

  n_general = int(input("Ingrese el número de datos: "))
  arr_x_general = []
  arr_y_general = []
  for a in range(1, n_general+1):
      arr_x_general.append(float(input("Ingrese el valor de x"+str(a)+": ")))
      arr_y_general.append(float(input("Ingrese el valor de y"+str(a)+": ")))

  dif_general = arr_x_general[1] - arr_x_general[0]
  dif_temp_general = 0
  for x in range(1, len(arr_x_general)-1):
      dif_temp_general = arr_x_general[x+1] - arr_x_general[x]
      if dif_temp_general != dif_general:
          print("Los contenidos no son uniformes, usando Interpolación de Lagrange")
          arr_x_lagrange = np.asarray(arr_x_general)
          arr_y_lagrange = np.asarray(arr_y_general)
          x_lagrange = arr_x_lagrange
          y_lagrange = arr_y_lagrange
          x_interp_lagrange = float(
              input("\nIngrese el valor a interpolar en g(x): "))
          if(x_interp_lagrange>arr_x_general[1] or x_interp_lagrange<arr_x_general[0]):
            output.clear()
            print("\nEl valor de x ingresado no se encuentra dentro del rango")
          poly = lagrange(x_lagrange, y_lagrange)
          print(poly)
          y_interp_lagrange = poly(x_interp_lagrange)
          print("\nEl valor de la interpolación de Lagrange en g(x) es: ",
                y_interp_lagrange)
          print("Generando gráfica de la interpolación")
          fig6,ax6 = plt.subplots()
          ax6.plot(arr_x_lagrange, arr_y_lagrange, 'bo')  # blue o
          ax6.plot(x_interp_lagrange, y_interp_lagrange, 'ro')  # red o
          ax6.plot(arr_x_lagrange, arr_y_lagrange, color='green',
                  linestyle='dashed', linewidth=1.2)
          ax6.set_title('Lagrange', fontsize=18)
          ax6.set_xlabel('x', fontsize=15)
          ax6.set_ylabel('g(x)', fontsize=15)
          fig6.show();
          exit
      else:
          print("Los contenidos son uniformes, usando Interpolación de Newton hacia adelante")
          arr_x_nwt_delante = np.asarray(arr_x_general)
          arr_y_nwt_delante = np.asarray(arr_y_general)
          x_nwt_delante = arr_x_nwt_delante
          n_nwt_delante = n_general
          y_nwt_delante = [[0 for i in range(n_nwt_delante)]
                          for j in range(n_nwt_delante)]

          for a in range(len(arr_y_nwt_delante)):
              y_nwt_delante[a][0] = arr_y_nwt_delante[a]

          for i in range(1, n_nwt_delante):
              for j in range(n_nwt_delante - i):
                  y_nwt_delante[j][i] = y_nwt_delante[j +
                                                      1][i - 1] - y_nwt_delante[j][i - 1]

          print("Imprimiendo coeficientes:\n")
          for i in range(n_nwt_delante):
              print(x_nwt_delante[i], end="\t")
              for j in range(n_nwt_delante - i):
                  print(y_nwt_delante[i][j], end="\t")
              print("")
          x_interp_nwt_delante = float(
              input("\nIngrese el valor a interpolar en g(x): "))
          if(x_interp_nwt_delante>arr_x_general[1] or x_interp_nwt_delante<arr_x_general[0]):
            output.clear()
            print("\nEl valor de x ingresado no se encuentra dentro del rango")
            raise SystemExit
          sum_nwt_delante = y_nwt_delante[0][0]
          u = (x_interp_nwt_delante -
              x_nwt_delante[0]) / (x_nwt_delante[1] - x_nwt_delante[0])
          for i in range(1, n_nwt_delante):
              sum_nwt_delante = sum_nwt_delante + \
                  (u_cal(u, i) * y_nwt_delante[0][i]) / fact(i)

          print("\nEl valor de la interpolación de Newton hacia adelante en g(x) es: " +
                str(sum_nwt_delante))
          print("Generando gráfica de la interpolación")
          fig7,ax7 = plt.subplots()
          ax7.plot(arr_x_nwt_delante, arr_y_nwt_delante, 'bo')  # blue o
          ax7.plot(x_interp_nwt_delante, sum_nwt_delante, 'ro')  # red o
          ax7.plot(arr_x_nwt_delante, arr_y_nwt_delante,
                  color='green', linestyle='dashed', linewidth=1.2)
          ax7.set_title('Newton hacia adelante', fontsize=18)
          ax7.set_xlabel('x', fontsize=15)
          ax7.set_ylabel('g(x)', fontsize=15)
          fig7.show();
          exit
except:
  output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")

"""<a name="section3"></a>
# Ecuaciones no lineales

## ¿Qué son?

Llamamos ecuacion no lineal a cualquier ecuación en la que alguna de sus incógnitas no es de primer grado, involucra polinomios de segundo grado, raíces, exponenciales, funciones trigonométricas, logaritmos, etcétera.

## ¿Cuál es su solución?

El propósito de los métodos descritos en esta libreta es encontrar las raíces de la ecuación ingresada a cada método, definimos a una raíz $ x $ de una función $ f(x) $, de tal manera que $ f(x) = 0$

Existen múltiples métodos como:
   * Gráfico
   * Bisectriz
   * Punto Fijo o Sucesiones Sucesivas
   * Newton Raphson
   * Falsa Posición
   * Secante
"""

# Commented out IPython magic to ensure Python compatibility.
# #@title Ejecutar esta celda para poder utilizar las calculadoras de ecuaciones no lineales
# %%capture
# from google.colab import output
# !pip install ipympl
# %matplotlib widget
# import numpy as np
# from numpy.linalg import norm
# import sympy as sp
# import matplotlib.pyplot as plt
# from scipy import optimize
# from IPython.display import Math,display
# sp.init_printing(use_latex='mathjax')
# import warnings
# import math
# import ipywidgets as widgets
# #warnings.filterwarnings('error')
# np.seterr(all='print')

"""## Método Gráfico

### ¿Cómo funciona?

El método gráfico sirve para poder obtener una aproximación a $f(x)=0$ al graficar la función y tomar nota de cuando se cruza el eje de las abscisas $x$, observando para qué valores de $x$, $f(x)=0$, cambiando el signo.

### ¿Cómo se puede utilizar?

Para utilizar el metodo, se debe ejecutar la **celda** de código siguiente y se ingresa una función.

El formato de funciones aceptado en la libreta es el siguiente:
   * Para representar productos $3x$ se ingresa ```3*x```
   * Para representar funciones trigonométricas $sen(x)$ se debe utilizar ```sin(x)```, las demás permanecen no cambiadas
   * Para representar exponenciales $e^x$ se debe usar ```exp(x)``` salvo un caso en específico que se detalla adelante.
   * Para representar potencias $x^2$ se debe utilizar ```x^2```
   
Un ejemplo de una ecuación ingresada sería $3x-sin(x)+e^x$ es: ```3*x -sin(x)+exp(x)```

Posterior a ingresar la función, se tendrá que especificar el rango de valores a evaluar en $f(x)$, a continuación se obtendrá la gráfica de $f(x)$ y se marcará en rojo los puntos donde se realiza el cambio de signo.
"""

#@title calculadora para el metodo grafico
try:
  x, y, z = sp.symbols("x y z")
  fun_graf = input('Ingrese la función: ')
  fun_sim_graf = sp.sympify(fun_graf)
  display(Math(sp.latex(fun_sim_graf)))
  check_graf = True
  
  #try:
  # obtener grado de la función si el rango especificado por el usuario no basta para encontrar todas las raíces
  #grado_graf = sp.degree(fun_sim_graf, gen=x)
  menor_graf = float(input("Ingrese el límite inferior del rango a evaluar: "))
  mayor_graf = float(input("Ingrese el límite mayor del rango a evaluar: "))
  rango_graf = np.arange(menor_graf, (mayor_graf+1))
  # crea una expresion de numpy para evaluar
  f_np_graf = sp.lambdify(x, fun_sim_graf, "numpy")
  resultado_np_graf = f_np_graf(rango_graf)  # evalua en el rango seleccionado
  signs = np.sign(resultado_np_graf)  # para obtener donde cruza 0
  signs[signs == 0] = -1
  cruces_cero_graf = np.where(np.diff(signs))[0]
  cambio = []  # valores del cambio de signo
  anterior_cambio = []  # valor anterior al cambio de signo
  
  for a in range(len(cruces_cero_graf)):
      temporal = cruces_cero_graf[a]
      anterior_cambio.append(resultado_np_graf[temporal])
      cambio.append(resultado_np_graf[temporal+1])
  
  rango_nuevo = []
  print("Rango establecido de", menor_graf, "a", mayor_graf)
  for a in range(0, len(cruces_cero_graf)):
      print("Para x en: ", rango_graf[cruces_cero_graf[a]],
            ", f(x) vale: ", anterior_cambio[a])
      print("Para x en: ", rango_graf[cruces_cero_graf[a]+1],
            ", f(x) vale: ", cambio[a], " cambio de signo")
      rango_nuevo.append(rango_graf[cruces_cero_graf[a]+1])
  if(len(cruces_cero_graf) == 1):
      print("Se recomienda aumentar el rango de evaluación")
  
  positivos = []  # para bisectriz
  negativos = []  # para bisectriz
  
  for i in range(int(menor_graf), int(mayor_graf)):
      if f_np_graf(i) > 0:
          if f_np_graf(i) in cambio:
              positivos.append(i)
          elif f_np_graf(i) in anterior_cambio:
              positivos.append(i)
      else:
          if f_np_graf(i) in cambio:
              negativos.append(i)
          elif f_np_graf(i) in anterior_cambio:
              negativos.append(i)
  
  fig = plt.figure()
  ax = plt.gca()  # get current axis
  ax.plot(rango_graf, resultado_np_graf)
  ax.grid(True)
  ax.spines['left'].set_position('zero')
  ax.spines['right'].set_color('none')
  ax.spines['bottom'].set_position('zero')
  ax.spines['top'].set_color('none')
  plt.plot(rango_nuevo, cambio, 'ro', label='Plot pogi')
  plt.show()
  #except:
  #check_graf = False
  #print("La función ingresada no se puede resolver por este método")
except:
  output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")

"""## Bisectriz

### ¿Cómo funciona?

Una bisectriz es una recta que corta los puntos de un plano de  tal manera que el lugar de corte sea equidistante a los extremos del plano, dividiendo siempre a la mitad.

Es un proceso iterativo que se repite hasta encontrar un cambio de signo, obteniendo una mejor aproximación a la raíz.

Su fórmula es $x = \dfrac{a+b}{2}$


Donde $a$ es el valor donde se encuentra el signo positivo y $b$ el valor donde se encuentra el signo negativo.

### ¿Cómo se puede utilizar?

Para aplicar el método de la bisectriz es necesario encontrar los puntos donde se cruza x, basándose en el método gráfico. Es **imperante** la ejecucion del método anterior para encontrar la tabla de valores
"""

#@title Calculadora para bisectriz
try:
  if check_graf:
      for i in range(len(positivos)):
          a = positivos[i]  # a siempre es donde se comporta positivo
          b = negativos[i]  # b siempre es donde se comporta negativo
          root = optimize.bisect(f_np_graf, a, b)
          print("La raíz entre a:", a, "y b:", b, "es:", root)
  else:
      print("La función ingresada no se puede resolver por este método")
except:
  output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")

"""## Punto Fijo

###¿Cómo funciona?
Este metodo consiste en transformar algebraicamente $f(x)=0$ a la forma equivalente $x = g(x)$

por ejemplo, la función: $2x^{2}-x-5=0$, se puede despejar de las siguientes maneras.

a) $x=2x^{2}-5 $

b) $x=\sqrt{x+\frac{5}{2}}$

C) $x=\frac{5}{2x-1}$

La utilidad de los despejes es proporcionar una formula para predicir un nuevo valor de x en función de un valor anterior, de manera iterativa.


###¿Cómo se puede utilizar?

Al ejecutar la calculadora para punto fijo el usuario obtiene la posibilad de ingresar una funcion, ya sea que deje que el sistema la despeje en manera automatica o que el usuario ingrese la funcion con un despeje. una vez se recibe la entrada de datos se regresa el resultado obtenido

*Se debe utilizar e^x para ingresar el exponencial



"""

#@title Calculadora para Punto Fijo
try:
  def listToString(s):

      # initialize an empty string
      str1 = ""

      # return string
      return (str1.join(s))


  def punto_fijo(f, e=0.00001):
      max_iter = 100
      error = 1
      x_start = 0
      i = 0
      xp = []
      while (error > e and i < max_iter):
          x_result = f(x_start)
          resultado = x_result[0]
          error = abs(resultado - x_start)
          x_start = resultado
          x_real = x_start.real
          xp.append(x_start)
          i += 1
          if(np.isnan(resultado)):
              print("Error interno del programa")
              print("Intenta con el otro despeje")
              break
          else:
              print("Iteración: " + str(i) + " Resultado: " +
                str(x_real) + " Error: {:.10f}".format(round(error, 10)))

      print("El resultado del método es:", resultado)


  w, x, y, z = sp.symbols("w x y z")
  decision = int(input('Para dejar que el sistema despeje su ecuación ingrese 1, de lo contrario ingrese 2 y su ecuación ya despejada. Mejores resultados para la ecuación despejada por el usuario'))
  if decision == 1:
      fun_pto = input('Ingrese la función: ')
      fun_sim_pto = sp.sympify(fun_pto)
      display(Math(sp.latex(fun_sim_pto)))

      #código para poder separar la ecuación en variables
      #tomamos el string del usuario, lo pasamos a una lista e iteramos buscando las x, sustituyendolas en la lista
      #pasandolas a string de nuevo y luego a funciones simbólicas
      #no es lo más eficiente pero es la implementaicón que se me ocurrió
      fun_sim_W = sp.sympify(fun_pto)
      fun_sim_Y = sp.sympify(fun_pto)
      fun_sim_Z = sp.sympify(fun_pto)
      contador = 0
      lista_fun_pto = list(fun_pto)
      listaCopia = list(fun_pto)
      listaCopia2 = list(fun_pto)
      listaCopia3 = list(fun_pto)
      for elemento in range(len(lista_fun_pto)):
          if lista_fun_pto[elemento] == 'x':
              if contador == 0:
                  listaCopia[elemento] = 'w'
                  exp = listToString(listaCopia)
                  fun_sim_W = sp.sympify(exp)
                  contador += 1
              elif contador == 1:
                  listaCopia2[elemento] = 'y'
                  exp = listToString(listaCopia2)
                  fun_sim_Y = sp.sympify(exp)
                  contador += 2
                  break
              elif contador == 2:
                  listaCopia3[elemento] = 'z'
                  exp = listToString(listaCopia3)
                  fun_sim_Z = sp.sympify(exp)
              else:
                  print('Demasiadas x')


      ecuaciones = []
      if(fun_sim_W != fun_sim_pto):
          despejadaW = sp.solve(fun_sim_W, w)
          ecuaciones.append(despejadaW)
      if(fun_sim_Y != fun_sim_pto):
          despejadaY = sp.solve(fun_sim_Y, y)
          ecuaciones.append(despejadaY)
      if(fun_sim_Z != fun_sim_pto):
          despejadaZ = sp.solve(fun_sim_Z, z)
          ecuaciones.append(despejadaZ)

      print("Despejes de la ecuación para x:\n")
      for ecuacion in ecuaciones:
          display(Math(sp.latex(ecuacion)))

      opcion = int(input("¿Qué despeje desea usar?")) - 1
      despeje = ecuaciones[opcion]
      funcion_np_pto = sp.lambdify(x, despeje, 'numpy')
      punto_fijo(funcion_np_pto)
  elif decision == 2:
      fun_pto = input('Ingrese la función: ')
      fun_sim_pto = sp.sympify(fun_pto)
      display(Math(sp.latex(fun_sim_pto)))
      funcion_np_pto = sp.lambdify(x, funcion_sim_pto, 'numpy')
      punto_fijo(funcion_np_pto)
except:
  output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")

"""## Newton Raphson
###¿Cómo funciona?
Consiste en un procedimiento que lleva la ecuación $f(x)=0$
Requiere una buena estimacion inicial, de lo contrario la solución iterativa puede divergir o converger a una solucion irrelevante

$x$ inicial puede ser $0$ o un valor cercano a la raiz

La formula que se utiliza es la siguiente:

$x_{i+1}= x_i-(\frac{f(x_i)}{f'(x_i)})$
###¿Cómo se puede utilizar?
Al momento que se ejecuta el método se requiere que el usuario ingrese la funcion a evaluar. de manera automatica se regresa su derivada. finalmente se debe ingresar la $x_o$ y se podrá observar las iteraciones y el resultado final

*Se debe utilizar exp(x) para el exponencial
"""

#@title Calculadora para Newton Raphson
try:
  def newton_raphson(func,func_prime,x_0,error=0.000001):
      maxiter = 100
      e = 1 
      i = 0
      while(i<maxiter and e>error):
          res = func(x_0)#.evalf
          res_prime = func_prime(x_0)#.evalf
          #res_prime=float(res)
          x = x_0 - (res/res_prime)
          resultado = x
          e_anterior = e
          e = abs(resultado-x_0)
          x_0 = resultado
          i+=1
          print("Iteración: " + str(i) + " Resultado: " + str(resultado) + " Error: " + str(e))
          if(e_anterior < e):
              print("La función parece comportarse de manera errática, resultados no garantizados")
              #i=100
      if(i==100):
          print("Número máximo de iteraciones alcanzado")
      print("El resultado es: " + str(resultado))


  w, x, y, z = sp.symbols("w x y z")
  fun_nwt = input('Ingrese la función: ')
  fun_sim_nwt = sp.sympify(fun_nwt)
  #converter()
  display(Math(sp.latex(fun_sim_nwt)))
  fun_prime_sim_nwt = fun_sim_nwt.diff(x)
  print("Derivada de la función: ")
  display(Math(sp.latex(fun_prime_sim_nwt)))
  x_0 = float(input("Ingrese el valor inicial de x0: "))
  fun_np_nwt = sp.lambdify(x,fun_sim_nwt,math)
  fun_prime_np_nwt = sp.lambdify(x,fun_prime_sim_nwt,math)
  newton_raphson(fun_np_nwt,fun_prime_np_nwt,x_0)
except:
  output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")

"""## Falsa posición
###¿Cómo funciona?
Se basa en si $f(b)$ está mucho más cercana a cero que $f(a)$, es logico que la raíz se encuentra más cerca de $b$ que de $a$

La formula que se utiliza de manera iterativa es la siguiente:

$x = a - \frac{f(a)(b-a)}{f(b)-f(a)}$

$a$ es el valor de $x$ antes de un cambio de signo y $b$ es el valor de $x$ despues de un signo

###¿Cómo se puede utilizar?
Primero se ejecuta la siguiente celda para activar el funcionamiento de la calculadoraa, consecuentemente debe ingresar la funcion con la cual quieres trabajar, finalmente se debe suministrar valores de $ a$ y $b$ correctos. se visualizara las iteraciones y el resultado final

*se debe usar exp(x) para el exponencial
"""

#@title Calculadora para Falsa Posición
try:
  def regula_falsi(f,a,b,e=0.00001):
      if f(a) * f(b) >=0:
          print("Los valores seleccionados de a y b no son válidos para el método")
      else:
          max_iter = 100
          error = 1
          x_start = a - (b-a) * f(a) / (f(b)-f(a))
          a = x_start
          i = 0
          xp = []
          while (error > e and i < max_iter):
              resultado = a - (b-a) * f(a) / (f(b)-f(a))
              error = abs(resultado - a)
              a = resultado
              i += 1
              print("Iteración: " + str(i) + " Resultado: " +str(resultado) + " Error: {:.10f}".format(round(error, 10)))

          print("El resultado del método es:", resultado)


  w, x, y, z = sp.symbols("w x y z")
  fun_fp = input('Ingrese la función: ')
  fun_sim_fp = sp.sympify(fun_fp)
  #converter()
  display(Math(sp.latex(fun_sim_fp)))
  fun_np_fp = sp.lambdify(x, fun_sim_fp, 'numpy')
  a = float(input("Ingrese el valor de a: "))
  b = float(input("Ingrese el valor de b: "))
  regula_falsi(fun_np_fp,a,b)
except:
  output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")

"""## Secante:
###¿Cómo funciona?
Predice la aproximación de una raíz extrapolando una tangente de la función del eje
x. Se basa en la fórmula de interpolación lineal.

se requiere de dos valores iniciales: $x_0=0$, $x_1=1$

La formula que se utiliza es la siguiente:
$x_{i+1}=x_{i+1}- (\frac{f(x_{i+1})(x_{i+1}-x_i)}{f(x_{i+1})-f(x_i)})$

###¿Cómo se puede utilizar?

Este método muy sencillo de utilizar, solo se ejecuta la celda contigua y se ingresa la funcion de la cual se quiere obtener la raiz y la calculadora se encarga del resto.

**Se debe usar exp(x) para el exponencial**
"""

#@title Calcular por el metodo de la Secante
try:
  def secante(f,x0,x1,e=0.00001):
      if(f(x0)*f(x1) >=0):
          print("Valores iniciales de 0 y 1 inválidos")
      else:
          maxiter = 100
          error = 1
          xi = x0
          xi_1 = x1
          xi_2 = xi_1 - (f(xi_1)*(xi_1-xi)/f(xi_1)-f(xi))
          xi=xi_1
          xi_1=xi_2
          i = 0
          while(error > e and i < maxiter):
              xi_2 = xi_1 - (f(xi_1)*(xi_1-xi)/f(xi_1)-f(xi))
              error = abs(f(xi_1))
              xi=xi_1
              xi_1=xi_2
              i+=1

              print("Iteración: " + str(i) + " Resultado: " +str(xi_1) + " Error: {:.10f}".format(round(error, 10)))
          print("El resultado del método es:", xi_1)
          
      

  w, x, y, z = sp.symbols("w x y z")
  fun_sc = input('Ingrese la función: ')
  fun_sim_sc = sp.sympify(fun_sc)
  #converter()
  display(Math(sp.latex(fun_sim_sc)))
  fun_np_sc = sp.lambdify(x, fun_sim_sc, 'numpy')
  x0 = 0
  x1 = 1
  secante(fun_np_sc,x0,x1)
except:
  output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")

"""<a name="section4"></a>
# Ecuaciones Lineales

## ¿Qué son?

Una ecuación lineal es una ecuación en la que cada uno de los términos que la componen tiene una variable de primer grado, es decir, que el exponente de su potencia es igual a 1. Por ejemplo $3x + y - 4z = 23$

Un sistema de ecuaciones lineales es un conjunto de ecuaciones lineales definidas y relacionadas entre sí. Por ejemplo $\begin{cases} 3x + 5y + z = 3\\ 7x – 2y + 4z = 7\\ -6x + 3y + 2z = -9\end{cases}$

## ¿Cuál es su solución?

Un sistema de ecuaciones lineales se considera solucionado cuando se encuentran los valores de las incógnitas que satisfagan todas y cada una de las ecuaciones individuales que componen al sistema. Por ejemplo, para $\begin{cases} 3x + 5y + z = 3\\ 7x – 2y + 4z = 7\\ -6x + 3y + 2z = -9\end{cases}$    
La solución sería: $\begin{array}{rcl} x & = & \dfrac{295}{229}\\ y & = & \dfrac{-15}{229}\\ z & = & \dfrac{-123}{229} \end{array}$

Para poder solucionar a los sistemas de ecuaciones existen distintos procedimientos algebraicos, gráficos o matriciales. En este capítulo se abordarán 5 métodos matriciales:
   * Montante
   * Gauss Jordan
   * Eliminación Gaussiana
   * Gauss Seidel
   * Jacobi
"""

# Commented out IPython magic to ensure Python compatibility.
# #@title Ejecutar este celda para poder ejecutar los métodos de ecuaciones lineales
# %%capture
# from google.colab import output
# !pip install ipympl
# %matplotlib widget
# import numpy as np
# import sympy as sp
# from IPython.display import Math,display
# sp.init_printing(use_latex='mathjax')
# import warnings
# import math
# import ipywidgets as widgets
# #warnings.filterwarnings('error')
# np.seterr(all='print')

"""## Montante

### ¿Cómo funciona?

Dentro de la matriz se toma a un elemento pivote, este pivote tiene que ser distinto a cero y considerar el signo que le corresponde por su ubicación en la determinante de la matriz.

La fórmula del Método Montante es:

$N.E. = \dfrac{(E.P.)(E.A.)-(E.C.F.P.)(E.C.C.P.)}{P.A.}$

Donde:
   * $N.E.$ es el nuevo elemento
   * $E.P.$ es el elemento pivote
   * $E.A.$ es el elemento actual
   * $E.C.F.P.$ es el elemento correspondiente a la fila del pivote
   * $E.C.C.P.$ es el elemento correspondiente a la columna del pivote
   * $P.A.$ es el pivote anterior
   
## ¿Cómo se puede utilizar?

Para usar este método, se debe ejecutar la **celda** de código siguiente e ingresar los coeficientes de las variables del sistema de ecuaciones y su solución.  
"""

#@title Calcular por el método de Montante
try:
  #https://stackoverflow.com/questions/41251911/check-if-an-array-is-a-multiple-of-another-array
  #el algoritmo de montante funciona, hay que revisar como se validan todas las entradas
  def coincident(one, two):
      if one[0]%two[0] == 0:
          return True
      else:
          rango = len(one)
          for v in range(1,rango):
              if one[v] % two[v] == 0:
                  return True
          return False

  n = int(input("Ingrese el número de variables del sistema"))
  m = []
  for i in range(0,n):
      m.append([int(j) for j in input("Ingrese los coeficientes de cada ecuación y su solución separados con un espacio").split()])
  matriz_np = np.array(m, dtype=object)
  print(matriz_np)
  x = matriz_np[0][0]
  if x == 0:
      matriz_np[[0, 1]] = matriz_np[[1, 0]] #swapea las filas si es 0
      x = matriz_np[0][0]
      if x == 0:
          matriz_np[[0, 2]] = matriz_np[[2, 0]]
          x = matriz_np[0][0]
          if x == 0:
              print("La matriz no se puede resolver, todos los coeficientes de la primer variable son 0")
              exit
  contenido_x = matriz_np[:3, :1].copy() #copia cada columna a un array de arrays
  contenido_y = matriz_np[:3, 1:2].copy()
  contenido_z = matriz_np[:3, 2:3].copy()
  soluciones = matriz_np[:3, 3:4].copy()
  flatten_x = np.reshape(contenido_x,-1) #flattea la copia a un array unidimensional
  flatten_y = np.reshape(contenido_y,-1)
  flatten_z = np.reshape(contenido_z,-1)
  flatten_sol = np.reshape(soluciones,-1)

  is_all_zero = np.all((flatten_y == 0)) #no checamos por x porque por eso se hace el reacomodo de filas
  if is_all_zero:
      print("La matriz no se puede resolver, todos los coeficientes de la segunda variable son 0")
      exit
  is_all_zero = np.all((flatten_z == 0))
  if is_all_zero:
      print("La matriz no se puede resolver, todos los coeficientes de la tercer variable son 0")
      exit
  is_all_zero = np.all((flatten_sol == 0))
  if is_all_zero:
      print("La matriz no se puede resolver, todas las soluciones son 0")
      exit

  '''
  multiplo_xy = coincident(flatten_x, flatten_y) #si las filas son múltiplos tampoco se puede resolver
  if multiplo_xy:
      print("Las ecuaciones son múltiplos completos, no se puede resolver")
      print("xy")
      exit
  else:
      multiplo_xz = coincident(flatten_x, flatten_z)
      if multiplo_xz:
          print("Las ecuaciones son múltiplos completos, no se puede resolver")
          print("xz")
          print(contenido_x)
          print(contenido_z)
          exit
      else:    
          multiplo_yz = coincident(flatten_y, flatten_z)
          if multiplo_yz:
              print("Las ecuaciones son múltiplos completos, no se puede resolver")
              print("yz")
              print(contenido_y)
              print(contenido_z)
              exit
          else:
              print("ok")
  '''


  pivAnt = 1
  for pivN in range(0,n):
    for r in range(0,n):
      for c in range(0,n+1):
        if c != pivN and r!= pivN:
          matriz_np[r][c]=(matriz_np[pivN][pivN] * matriz_np[r][c] -matriz_np[r][pivN]*matriz_np[pivN][c])/pivAnt
      if r != pivN:
        matriz_np[r][pivN]	= 0
    print ("\n" + str(matriz_np))
    pivAnt=matriz_np[pivN][pivN]

  print ("Matriz final:\n" + str(matriz_np))
  x=matriz_np[0][n]/matriz_np[0][0]
  y=matriz_np[1][n]/matriz_np[1][1]
  z=matriz_np[2][n]/matriz_np[2][2]


  print ("\nValores de x,y,z:") 
  print ("X = " + str(x))
  print ("Y = " + str(y))
  print ("Z = " + str(z))
except:
  output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")

"""## Gauss Jordan

###¿Cómo funciona?
Este método es una variación de la eliminación gaussiana.
Todos los renglones se normalizan al dividirlos entre su elemento pivote. De esta
forma, el paso de eliminación genera una matriz identidad, y así obtener la solución.

###¿Como se puede utilizar?

Al ejecutarse la celda de código siguiente se debe de ingresar el numero de incognitas del sistema de ecuaciones, consecuentemente se ingresan los coeficientes de cada ecuacion, asi como su solucion, finalmente se mostrara la solucion del problema
"""

#@title Calcular por el método de Gauss Jordan
try:
  #falta validar
  n = int(input("Ingrese el número de incógnitas"))
  m_coef = []
  for i in range(0,n):
      m_coef.append([int(j) for j in input("Ingrese los coeficientes de cada ecuación separados con un espacio").split()])
  matriz_coef_np = np.array(m_coef, dtype=object)
  m_sol = []
  for i in range(0,n):
      m_sol.append([int(j) for j in input("Ingrese una por una las soluciones de cada ecuación").split()])
  matriz_sol_np = np.array(m_sol, dtype=object)
  #matriz de coeficientes A
  #vector de soluciones
  A = matriz_coef_np

  B = matriz_sol_np

  # PROCEDIMIENTO
  casicero = 1e-15 # Considerar como 0
  # Evitar truncamiento en operaciones
  A = np.array(A,dtype=float) 

  # Matriz aumentada
  AB = np.concatenate((A,B),axis=1)
  AB0 = np.copy(AB)

  # Pivoteo parcial por filas
  tamano = np.shape(AB)
  n = tamano[0]
  m = tamano[1]

  # Para cada fila en AB
  for i in range(0,n-1,1):
      # columna desde diagonal i en adelante
      columna = abs(AB[i:,i])
      dondemax = np.argmax(columna)
      
      # dondemax no está en diagonal
      if (dondemax !=0):
          # intercambia filas
          temporal = np.copy(AB[i,:])
          AB[i,:] = AB[dondemax+i,:]
          AB[dondemax+i,:] = temporal
  AB1 = np.copy(AB)

  # eliminacion hacia adelante
  for i in range(0,n-1,1):
      pivote = AB[i,i]
      adelante = i+1
      for k in range(adelante,n,1):
          factor = AB[k,i]/pivote
          AB[k,:] = AB[k,:] - AB[i,:]*factor
  AB2 = np.copy(AB)

  # elimina hacia atras
  ultfila = n-1
  ultcolumna = m-1
  for i in range(ultfila,0-1,-1):
      pivote = AB[i,i]
      atras = i-1 
      for k in range(atras,0-1,-1):
          factor = AB[k,i]/pivote
          AB[k,:] = AB[k,:] - AB[i,:]*factor
      # diagonal a unos
      AB[i,:] = AB[i,:]/AB[i,i]
  X = np.copy(AB[:,ultcolumna])
  X = np.transpose([X])


  # SALIDA
  print('Matriz aumentada:')
  print(AB0)
  print('Pivoteo parcial por filas')
  print(AB1)
  print('Eliminacion hacia adelante')
  print(AB2)
  print('Eliminación hacia atrás')
  print(AB)
  print('Solución del sistema: ')
  print(X)
except:
  output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")

"""##Eliminación Gaussiana
###¿Cómo funciona?
En este método se aplican varias operaciones de renglón, que son las siguientes:

1) Multiplicar toda la fila por una constante distinta de cero.

2) Sumar o restar un múltiplo de una ecuación a otra.

3) Intercambiar de posición dos ecuaciones.

Para facilitar el proceso, se forma una matriz aumentada que contiene solamente los
coeficientes de las ecuaciones.

Al final del proceso, el sistema se reduce a una forma triangular, donde la última
ecuación tiene la solución de la última incógnita.

Posteriormente, se aplica un proceso de sustitución hacia atrás para ir calculando
progresivamente los valores de las otras incógnitas.
###¿Como se puede utilizar?

Para usar este método, se debe ejecutar la **celda** de código siguiente e ingresar los coeficientes de las variables del sistema de ecuaciones y su solución.  
"""

#@title Calculadora para eliminación Gaussiana
try:
  #falta validar
  n = int(input("Ingrese el número de incógnitas"))
  m_coef = []
  for i in range(0,n):
      m_coef.append([int(j) for j in input("Ingrese los coeficientes de cada ecuación separados con un espacio").split()])
  matriz_coef_np = np.array(m_coef, dtype=object)
  m_sol = []
  for i in range(0,n):
      m_sol.append([int(j) for j in input("Ingrese una por una las soluciones de cada ecuación").split()])
  matriz_sol_np = np.array(m_sol, dtype=object)
  #matriz de coeficientes A
  #vector de soluciones
  A = matriz_coef_np

  B = matriz_sol_np


  # PROCEDIMIENTO
  casicero = 1e-15 # Considerar como 0
  # Evitar truncamiento en operaciones
  A = np.array(A,dtype=float) 

  # Matriz aumentada
  AB = np.concatenate((A,B),axis=1)
  AB0 = np.copy(AB)

  # Pivoteo parcial por filas
  tamano = np.shape(AB)
  n = tamano[0]
  m = tamano[1]

  # Para cada fila en AB
  for i in range(0,n-1,1):
      # columna desde diagonal i en adelante
      columna = abs(AB[i:,i])
      dondemax = np.argmax(columna)
      
      # dondemax no está en diagonal
      if (dondemax !=0):
          # intercambia filas
          temporal = np.copy(AB[i,:])
          AB[i,:] = AB[dondemax+i,:]
          AB[dondemax+i,:] = temporal
  AB1 = np.copy(AB)

  # eliminación hacia adelante
  for i in range(0,n-1,1):
      pivote = AB[i,i]
      adelante = i+1
      for k in range(adelante,n,1):
          factor = AB[k,i]/pivote
          AB[k,:] = AB[k,:] - AB[i,:]*factor

  # sustitución hacia atrás
  ultfila = n-1
  ultcolumna = m-1
  X = np.zeros(n,dtype=float)

  for i in range(ultfila,0-1,-1):
      suma = 0
      for j in range(i+1,ultcolumna,1):
          suma = suma +AB[i,j]*X[j]
      b = AB[i,ultcolumna]
      X[i] = (b-suma)/AB[i,i]

  X = np.transpose([X])


  # SALIDA
  print('Matriz aumentada:')
  print(AB0)
  print('Pivoteo parcial por filas')
  print(AB1)
  print('Eliminación hacia adelante')
  print(AB)
  print('Solución del sistema: ')
  print(X)
except:
  output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")

"""## Gauss Seidel
###¿Cómo funciona?
Es un método iterativo y por lo mismo, resulta bastante eficiente. Para un sistema de
“n” ecuaciones es comúnmente utilizado.

Es necesario que en la matriz, cada elemento de la diagonal principal sea mayor que
la suma de los valores de todos los demás elementos de la misma fila. Considerar
valores absolutos. 
###¿Como se puede utilizar?
Al ejecutarse la celda de código siguiente se debe de ingresar el numero de incognitas del sistema de ecuaciones, consecuentemente se ingresan los coeficientes de cada ecuacion, asi como su solucion, finalmente se mostrara la solucion del problema
"""

#@title Calcular por el método de Gauss Seidel
try:
  def is_diagonally_dominant(x):
      abs_x = np.abs(x)
      return np.all( 2*np.diag(abs_x) >= np.sum(abs_x, axis=1) )


  #falta validar
  n = int(input("Ingrese el número de incógnitas"))
  m_coef = []
  for i in range(0,n):
      m_coef.append([int(j) for j in input("Ingrese los coeficientes de cada ecuación separados con un espacio").split()])
  matriz_coef_np = np.array(m_coef, dtype=object)
  m_sol = []
  for i in range(0,n):
      m_sol.append([int(j) for j in input("Ingrese una por una las soluciones de cada ecuación").split()])
  matriz_sol_np = np.array(m_sol, dtype=object)
  #matriz de coeficientes A
  #vector de soluciones
  A = matriz_coef_np

  B = matriz_sol_np

  if(is_diagonally_dominant(A)):
      X0  = np.zeros(n)
      tolera = 0.001
      iteramax = 100


      # PROCEDIMIENTO

      # Gauss-Seidel
      tamano = np.shape(A)
      n = tamano[0]
      m = tamano[1]
      #  valores iniciales
      X = np.copy(X0)
      diferencia = np.ones(n, dtype=float)
      errado = 2*tolera

      itera = 0
      while not(errado<=tolera or itera>iteramax):
          # por fila
          for i in range(0,n,1):
              # por columna
              suma = 0 
              for j in range(0,m,1):
                  # excepto diagonal de A
                  if (i!=j): 
                      suma = suma-A[i,j]*X[j]

              nuevo = (B[i]+suma)/A[i,i]
              diferencia[i] = np.abs(nuevo-X[i])
              X[i] = nuevo
          errado = np.max(diferencia)
          itera = itera + 1
          print("Iteracion: " + str(itera))
          print(X)


      # revisa si NO converge
      if (itera>iteramax):
          X=0
      # revisa respuesta
      verifica = np.dot(A,X)

      # SALIDA
      print('Las respuestas del sistema son: ')
      print(X)
      
  else:
      print("La matriz no tiene diagonal dominante, prueba a reacomodarla")
      exit()
except:
  output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")

"""## Jacobi
###¿Cómo funciona?
Es utilizado para un sistema de “n” ecuaciones pues es eficiente al igual que el
método anterior.

Se requiere que en la matriz, cada elemento de la diagonal principal sea mayor que la
suma de los valores de todos los demás elementos de la misma fila. Considerar
valores absolutos.
###¿Como se puede utilizar?

Para usar este método, se debe ejecutar la **celda** de código siguiente e ingresar los coeficientes de las variables del sistema de ecuaciones y su solución.  
"""

#@title Calcular por el método de Jacobi
try:
  def is_diagonally_dominant(x):
      abs_x = np.abs(x)
      return np.all( 2*np.diag(abs_x) >= np.sum(abs_x, axis=1) )

  def jacobi(A, b, x_init, epsilon=0.001, max_iterations=500):
      D = np.diag(np.diag(A))
      LU = A - D
      x = x_init
      D_inv = np.diag(1 / np.diag(D))
      for i in range(1,max_iterations):
          x_new = np.dot(D_inv, b - np.dot(LU, x))
          if np.linalg.norm(x_new - x) < epsilon:
              return x_new
          x = x_new
          val_x = x[0][0]
          val_y = x[1][1]
          try:
              val_z = x[2][2]
          except:
              val_z = None
          if val_z is not None:
              str_respuesta = "La solución actual es: " + str(val_x) + " " + str(val_y) + " " +str(val_z)
          else:
              str_respuesta = "La solución actual es: " + str(val_x) + " " + str(val_y)
          print("Iteracion: " + str(i))
          print(str_respuesta)
      return x




  #falta validar
  n = int(input("Ingrese el número de incógnitas"))
  m_coef = []
  for i in range(0,n):
      m_coef.append([int(j) for j in input("Ingrese los coeficientes de cada ecuación separados con un espacio").split()])
  matriz_coef_np = np.array(m_coef, dtype=object)
  m_sol = []
  for i in range(0,n):
      m_sol.append([int(j) for j in input("Ingrese una por una las soluciones de cada ecuación").split()])
  matriz_sol_np = np.array(m_sol, dtype=object)
  #matriz de coeficientes A
  #vector de soluciones
  A = matriz_coef_np

  b = matriz_sol_np
  x_init = np.ones(len(b))
  if is_diagonally_dominant(A):
      x = jacobi(A, b, x_init)
      val_x = x[0][0]
      val_y = x[1][1]
      try:
          val_z = x[2][2]
      except:
          val_z = None
      if val_z is not None:
          str_respuesta = "La solución es: " + str(val_x) + " " + str(val_y) + " " +str(val_z)
      else:
          str_respuesta = "La solución es: " + str(val_x) + " " + str(val_y)
      print(str_respuesta)
  else:
      print("La matriz no tiene diagonal dominante, prueba a reacomodarla")
      exit()
except:
  #output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")

"""<a name="section5"></a>
# Minimos Cuadrados

## ¿Qué son?

Los mínimos cuadrados constituyen una herramienta del análisis numérico que nos permite, en base a un conjunto de datos pertenecientes a una variable dependiente y una independiente, encontrar una función algebraica que se "ajuste" mejor a las coordenadas, aproximando óptimamente a los puntos en el plano, obteniendo una curva que minimiza la dispersión entre si misma y los puntos.

## ¿Cuál es su solución?

Los mínimos cuadrados se pueden aplicar con distintas funciones para ajustar, se considera solucionado un problema de mínimos cuadrados cuando se obtiene la función de ajuste y se grafican los datos originales contra los datos pasados por la función de ajuste. Existen distintas funciones que se pueden tomar para hacer el ajuste como:
   * Línea Recta
   * Cuadrática
   * Cúbica
   * Lineal con Función
   * Cuadrática con Función
"""

# Commented out IPython magic to ensure Python compatibility.
# #@title Ejecutar esta celda para poder comenzar a trabajar con Mínimos Cuadrados
# %%capture
# from google.colab import output
# !pip install ipympl
# %matplotlib widget
# import numpy as np
# import sympy as sp
# import matplotlib.pyplot as plt
# sp.init_printing(use_latex='mathjax')
# import sys
# from IPython.display import Math,display

"""## Línea Recta:

### ¿Cómo funciona?

Los mínimos cuadrados por línea recta intentan ajustar una línea recta a varios puntos $(x_1,y_1),(x_2,y_2), ... (x_n, y_n)$ usando la ecuación $g(x) = a_0 + a_1x$

$a_0, a_1$ representan coeficientes de la intersección de la pendiente de la línea con el eje $x$

Para obtener los coeficientes y a $g(x)$ es necesario trabajar con una matriz de la siguiente manera:

$$\left( \begin{matrix} a_0 & a_1x & g(x) \\ n & \Sigma x & \Sigma y \\ \Sigma x & \Sigma x^2 & \Sigma xy \end{matrix} \right) $$

Donde n es el número de valores a ajustar, y $\Sigma$ representa la sumatoria de los valores.
### ¿Cómo se puede utilizar?

Para usar este método, hay que ejecutar la **celda** de código siguiente e ingresar primero el valor de $n$, posteriormente los valores de $x_1 ... x_n$ y los valores de $y_1 ... y_n$
"""

#@title Calculadora para el método de mínimos cuadrados por linea recta
try:
  n = int(input("Ingrese el número de valores de x: "))
  arr_x_lineaR = []
  for i in range(n):
      val_x = float(input("Ingrese el valor de " + "x" + str(i+1) +": "))
      arr_x_lineaR.append(val_x)
  arr_y_lineaR = []
  for i in range(n):
      val_y = float(input("Ingrese el valor de " + "y" + str(i+1) +": "))
      arr_y_lineaR.append(val_y)
  print("\nValores de x: ")
  print(arr_x_lineaR)
  print("\nValores de y: ")
  print(arr_y_lineaR)


  #n = 6
  #arr_x_lineaR = [1.1, 1.9, 2.4, 4.8, 5.1, 10.5]
  #arr_y_lineaR = [2.5, 2.7, 3.7, 5.2, 6.0, 8.3]

  sigma_x = np.sum(arr_x_lineaR)
  sigma_y = np.sum(arr_y_lineaR)
  x_cuadrada = np.power(arr_x_lineaR, 2)
  sigma_x_cuadrada = np.sum(x_cuadrada)
  xy_mult = np.multiply(arr_x_lineaR, arr_y_lineaR)
  sigma_xy = np.sum(xy_mult)

  matriz_impresa = np.array([[n, sigma_x, sigma_y], [sigma_x, sigma_x_cuadrada, sigma_xy]])
  print("\nCoeficientes de la matriz: ")
  print(matriz_impresa)

  matriz_coef = matriz_impresa.copy()
  matriz_coef = np.delete(matriz_coef, 2, 1)
  matriz_gx = matriz_impresa.copy()
  matriz_gx = np.delete(matriz_gx, [0, 1], 1)

  soluciones = np.linalg.solve(matriz_coef, matriz_gx)

  a_0 = soluciones[0][0]
  a_1 = soluciones[1][0]

  print("El valor de a0 es: " + str(a_0))
  print("El valor de a1 es: " + str(a_1))

  nuevos = []
  for x_vieja in arr_x_lineaR:
      elemento = a_0 + a_1*x_vieja
      nuevos.append(elemento)

  for i in range(n):
      val_x_nueva = nuevos[i]
      print("El valor de x" + str(i+1) + " ajustada con g(x) es:", val_x_nueva)

  fig1, ax1 = plt.subplots()
  ax1.plot(arr_x_lineaR, arr_y_lineaR, 'bo', label= 'Valores originales') #puntos viejos
  ax1.plot(nuevos, arr_y_lineaR, 'ro', label='Valores ajustados') #puntos nuevos
  ax1.plot(nuevos, arr_y_lineaR, color='red',linewidth=1.2) #linea nueva
  ax1.plot(arr_x_lineaR, arr_y_lineaR, color='blue',linewidth=1.2) #linea vieja
  ax1.set_title('Mínimos Cuadrados con Línea recta', fontsize=18)
  ax1.set_xlabel('x', fontsize=15)
  ax1.set_ylabel('y', fontsize=15)
  ax1.legend(markerfirst=False)
  fig1.show();
except:
  output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")

"""## Cuadrática:

### ¿Cómo funciona?

Los mínimos cuadrados por función cuadrática intentan ajustar una función cuadrática a varios puntos $(x_1,y_1),(x_2,y_2), ... (x_n, y_n)$ usando la ecuación $g(x) = a_0 + a_1x + a_2x^2$

$a_0, a_1, a_2$ representan coeficientes de la intersección de la pendiente de la línea con el eje $x$

Para obtener los coeficientes y a $g(x)$ es necesario trabajar con una matriz de la siguiente manera:

$$\left( \begin{matrix} a_0 & a_1x & a_2x^2 & g(x) \\ n & \Sigma x & \Sigma x^2 & \Sigma y \\ \Sigma x & \Sigma x^2 & \Sigma x^3 & \Sigma xy \\ \Sigma x^2 & \Sigma x^3 & \Sigma x^4 & \Sigma x^2y \end{matrix} \right) $$

Donde n es el número de valores a ajustar, y $\Sigma$ representa la sumatoria de los valores.
### ¿Cómo se puede usar?

Para usar este método, hay que ejecutar la **celda** de código siguiente e ingresar primero el valor de $n$, posteriormente los valores de $x_1 ... x_n$ y los valores de $y_1 ... y_n$
"""

#@title Calculadora para el método de mínimos cuadrados por cuadrática
try:
  n = int(input("Ingrese el número de valores de x: "))
  arr_x_cuad = []
  for i in range(n):
      val_x = float(input("Ingrese el valor de " + "x" + str(i+1) +": "))
      arr_x_cuad.append(val_x)
  arr_y_cuad = []
  for i in range(n):
      val_y = float(input("Ingrese el valor de " + "y" + str(i+1) +": "))
      arr_y_cuad.append(val_y)
  print("\nValores de x: ")
  print(arr_x_cuad)
  print("\nValores de y: ")
  print(arr_y_cuad)

  #n = 6
  #arr_x_cuad= [1.1, 1.9, 2.4, 4.8, 5.1, 10.5]
  #arr_y_cuad = [2.5, 2.7, 3.7, 5.2, 6.0, 8.3]


  sigma_x_cuad = np.sum(arr_x_cuad)
  sigma_y_cuad = np.sum(arr_y_cuad)
  x_cuadrada_cuad = np.power(arr_x_cuad, 2)
  x_cubica_cuad = np.power(arr_x_cuad, 3)
  x_cuarta_cuad = np.power(arr_x_cuad, 4)
  sigma_x_cuadrada_cuad = np.sum(x_cuadrada_cuad)
  sigma_x_cubica_cuad = np.sum(x_cubica_cuad)
  sigma_x_cuarta_cuad = np.sum(x_cuarta_cuad)
  xy_mult_cuad = np.multiply(arr_x_cuad, arr_y_cuad)
  x2y_mult_cuad = np.multiply(x_cuadrada_cuad, arr_y_cuad)
  sigma_xy_cuad = np.sum(xy_mult_cuad)
  sigma_x2y_cuad = np.sum(x2y_mult_cuad)

  matriz_impresa = ([[n, sigma_x_cuad, sigma_x_cuadrada_cuad, sigma_y_cuad], [sigma_x_cuad, sigma_x_cuadrada_cuad, sigma_x_cubica_cuad, sigma_xy_cuad],
                    [sigma_x_cuadrada_cuad, sigma_x_cubica_cuad, sigma_x_cuarta_cuad, sigma_x2y_cuad]])

  print("\nCoeficientes de la matriz: ")
  print(matriz_impresa)

  matriz_coef = matriz_impresa.copy()
  matriz_coef = np.delete(matriz_coef, 3, 1)
  matriz_gx = matriz_impresa.copy()
  matriz_gx = np.delete(matriz_gx, [0, 2], 1)

  soluciones = np.linalg.solve(matriz_coef, matriz_gx)

  a_0 = soluciones[0][1]
  a_1 = soluciones[1][1]
  a_2 = soluciones[2][1]

  print("El valor de a0 es: " + str(a_0))
  print("El valor de a1 es: " + str(a_1))
  print("El valor de a2 es: " + str(a_2))

  nuevos_cuad = []
  for x_vieja in arr_x_cuad:
      elemento = a_0 + (a_1*x_vieja) + (a_2*(np.power(x_vieja, 2)))
      nuevos_cuad.append(elemento)

  for i in range(n):
      val_x_nueva = nuevos_cuad[i]
      print("El valor de x" + str(i+1) + " ajustada con g(x) es:", val_x_nueva)

  fig2,ax2 = plt.subplots()
  ax2.plot(arr_x_cuad, arr_y_cuad, 'bo', label= 'Valores originales') #puntos viejos
  ax2.plot(nuevos_cuad, arr_y_cuad, 'ro', label='Valores ajustados') #puntos nuevos
  ax2.plot(nuevos_cuad, arr_y_cuad, color='red',linewidth=1.2) #linea nueva
  ax2.plot(arr_x_cuad, arr_y_cuad, color='blue',linewidth=1.2) #linea vieja
  ax2.set_title('Mínimos Cuadrados con Cuadrática', fontsize=18)
  ax2.set_xlabel('x', fontsize=15)
  ax2.set_ylabel('y', fontsize=15)
  ax2.legend(markerfirst=False)
  fig2.show();
except:
  output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")

"""## Cúbica

### ¿Cómo funciona?

Los mínimos cuadrados por función cúbica intentan ajustar una función cúbica a varios puntos $(x_1,y_1),(x_2,y_2), ... (x_n, y_n)$ usando la ecuación $g(x) = a_0 + a_1x + a_2x^2 + a_3x^3$

$a_0, a_1, a_2, a_3$ representan coeficientes de la intersección de la pendiente de la línea con el eje $x$

Para obtener los coeficientes y a $g(x)$ es necesario trabajar con una matriz de la siguiente manera:

$$\left( \begin{matrix} a_0 & a_1x & a_2x^2 & a_3x^3 & g(x) \\ n & \Sigma x & \Sigma x^2 & \Sigma x^3 &  \Sigma y \\ \Sigma x & \Sigma x^2 & \Sigma x^3 & \Sigma x^4 &  \Sigma xy \\ \Sigma x^2 & \Sigma x^3 & \Sigma x^4 & \Sigma x^5 &  \Sigma x^2y \\ \Sigma x^3 & \Sigma x^4 & \Sigma x^5 & \Sigma x^6 & \Sigma x^3y \end{matrix} \right) $$

Donde n es el número de valores a ajustar, y $\Sigma$ representa la sumatoria de los valores.
### ¿Cómo se puede usar?

Para usar este método, hay que ejecutar la **celda** de código siguiente e ingresar primero el valor de $n$, posteriormente los valores de $x_1 ... x_n$ y los valores de $y_1 ... y_n$
"""

#@title Calculadora para mínimos cuadrados por función cúbica
try:
  n = int(input("Ingrese el número de valores de x: "))
  arr_x_cub = []
  for i in range(n):
      val_x = float(input("Ingrese el valor de " + "x" + str(i+1) +": "))
      arr_x_cub.append(val_x)
  arr_y_cub = []
  for i in range(n):
      val_y = float(input("Ingrese el valor de " + "y" + str(i+1) +": "))
      arr_y_cub.append(val_y)
  print("\nValores de x: ")
  print(arr_x_cub)
  print("\nValores de y: ")
  print(arr_y_cub)


  #n = 6
  #arr_x_cub= [1.1, 1.9, 2.4, 4.8, 5.1, 10.5]
  #arr_y_cub = [2.5, 2.7, 3.7, 5.2, 6.0, 8.3]


  sigma_x_cub = np.sum(arr_x_cub)
  sigma_y_cub = np.sum(arr_y_cub)
  x_cuadrada_cub = np.power(arr_x_cub, 2)
  x_cubica_cub = np.power(arr_x_cub, 3)
  x_cuarta_cub = np.power(arr_x_cub, 4)
  x_quinta_cub = np.power(arr_x_cub, 5)
  x_sexta_cub = np.power(arr_x_cub, 6)
  sigma_x_cuadrada_cub = np.sum(x_cuadrada_cub)
  sigma_x_cubica_cub = np.sum(x_cubica_cub)
  sigma_x_cuarta_cub = np.sum(x_cuarta_cub)
  sigma_x_quinta_cub = np.sum(x_quinta_cub)
  sigma_x_sexta_cub = np.sum(x_sexta_cub)
  xy_mult_cub = np.multiply(arr_x_cub, arr_y_cub)
  x2y_mult_cub = np.multiply(x_cuadrada_cub, arr_y_cub)
  x3y_mult_cub = np.multiply(x_cubica_cub, arr_y_cub)
  sigma_xy_cub = np.sum(xy_mult_cub)
  sigma_x2y_cub = np.sum(x2y_mult_cub)
  sigma_x3y_cub = np.sum(x3y_mult_cub)

  matriz_impresa = ([[n, sigma_x_cub, sigma_x_cuadrada_cub, sigma_x_cubica_cub, sigma_y_cub],
                      [sigma_x_cub, sigma_x_cuadrada_cub, sigma_x_cubica_cub, sigma_x_cuarta_cub,sigma_xy_cub],
                      [sigma_x_cuadrada_cub, sigma_x_cubica_cub, sigma_x_cuarta_cub, sigma_x_quinta_cub, sigma_x2y_cub],
                      [sigma_x_cubica_cub, sigma_x_cuarta_cub, sigma_x_quinta_cub, sigma_x_sexta_cub, sigma_x3y_cub]])

  print("\nCoeficientes de la matriz: ")
  print(matriz_impresa)

  matriz_coef = matriz_impresa.copy()
  matriz_coef = np.delete(matriz_coef, 4, 1)
  matriz_gx = matriz_impresa.copy()
  matriz_gx = np.delete(matriz_gx, [0, 3], 1)

  soluciones = np.linalg.solve(matriz_coef, matriz_gx)
  print(soluciones)


  a_0 = soluciones[0][2]
  a_1 = soluciones[1][2]
  a_2 = soluciones[2][2]
  a_3 = soluciones[3][2]

  print("El valor de a0 es: " + str(a_0))
  print("El valor de a1 es: " + str(a_1))
  print("El valor de a2 es: " + str(a_2))
  print("El valor de a3 es: " + str(a_3))

  nuevos_cub = []
  for x_vieja in arr_x_cub:
      elemento = a_0 + (a_1*x_vieja) + (a_2*(np.power(x_vieja, 2))) + (a_3*(np.power(x_vieja, 3)))
      nuevos_cub.append(elemento)

  for i in range(n):
      val_x_nueva = nuevos_cub[i]
      print("El valor de x" + str(i+1) + " ajustada con g(x) es:", val_x_nueva)
  fig3,ax3=plt.subplots()
  ax3.plot(arr_x_cub, arr_y_cub, 'bo', label= 'Valores originales') #puntos viejos
  ax3.plot(nuevos_cub, arr_y_cub, 'ro', label='Valores ajustados') #puntos nuevos
  ax3.plot(nuevos_cub, arr_y_cub, color='red',linewidth=1.2) #linea nueva
  ax3.plot(arr_x_cub, arr_y_cub, color='blue',linewidth=1.2) #linea vieja
  ax3.set_title('Mínimos Cuadrados con Cúbica', fontsize=18)
  ax3.set_xlabel('x', fontsize=15)
  ax3.set_ylabel('y', fontsize=15)
  ax3.legend(markerfirst=False)
  fig3.show();
except:
  output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")

"""## Lineal con función

### ¿Cómo funciona?

Los mínimos cuadrados por lineal con función intentan ajustar una función lineal en conjunto con una función a escoger, a varios puntos $(x_1,y_1),(x_2,y_2), ... (x_n, y_n)$ usando la ecuación $g(x) = a_0 + a_1x + a_2x$* función$(x)$

Las funciones que se pueden usar son: $e^x$, $sin(x), cos(x), tan(x), ln(x)$, etcétera.

$a_0, a_1, a_2$ representan coeficientes de la intersección de la pendiente de la línea con el eje $x$

Para obtener los coeficientes y a $g(x)$ es necesario trabajar con una matriz de la siguiente manera:

$$\left( \begin{matrix} a_0 & a_1x & a_2f(x) & g(x) \\ n & \Sigma x & \Sigma f(x) & \Sigma y \\ \Sigma x & \Sigma x^2 & \Sigma xf(x) & \Sigma xy \\ \Sigma f(x) & \Sigma xf(x) & \Sigma f(x^2) & \Sigma yf(x) \end{matrix} \right) $$

Donde n es el número de valores a ajustar, y $\Sigma$ representa la sumatoria de los valores.
### ¿Cómo se puede usar?

Para usar este método, hay que ejecutar la **celda** de código siguiente e ingresar primero el valor de $n$, posteriormente los valores de $x_1 ... x_n$ y los valores de $y_1 ... y_n$
"""

#@title Calculadora para mínimos cuadrados con lineal con función
try:
  x, y, z = sp.symbols("x y z")
  n = int(input("Ingrese el número de valores de x: "))
  arr_x_lineaF = []
  for i in range(n):
      val_x = float(input("Ingrese el valor de " + "x" + str(i+1) +": "))
      arr_x_lineaF.append(val_x)
  arr_y_lineaF = []
  for i in range(n):
      val_y = float(input("Ingrese el valor de " + "y" + str(i+1) +": "))
      arr_y_lineaF.append(val_y)
  print("\nValores de x: ")
  print(arr_x_lineaF)
  print("\nValores de y: ")
  print(arr_y_lineaF)


  dict_funciones = {'1': 'e^x', '2': 'sin(x)', '3': 'cos(x)', '4': 'tan(x)', '5':'ln(x)'}
  for funcion in dict_funciones.values():
      display(Math(funcion))

  decision = input("Ingrese el número de la función que desea usar")
  dict_funciones['1'] = 'exp(x)'
  dict_funciones['5'] = 'log(x)'
  funcion_usar = dict_funciones.get(decision)
  funcion_sim_usar = sp.sympify(funcion_usar)
  funcion_np_usar = sp.lambdify(x, funcion_sim_usar, 'numpy')

  sigma_x = np.sum(arr_x_lineaF)
  sigma_y = np.sum(arr_y_lineaF)
  x_cuadrada = np.power(arr_x_lineaF, 2)
  x_funcion = funcion_np_usar(arr_x_lineaF)
  sigma_x_fun = np.sum(x_funcion)
  x2_funcion = funcion_np_usar(x_cuadrada)
  sigma_x2_fun = np.sum(x2_funcion)
  x_por_funcionx = np.multiply(arr_x_lineaF, x_funcion)
  sigma_x_porfunx = np.sum(x_por_funcionx)
  y_por_funcion_x = np.multiply(arr_y_lineaF, x_funcion)
  sigma_yporfunx = np.sum(y_por_funcion_x)
  sigma_x_cuadrada = np.sum(x_cuadrada)
  xy_mult = np.multiply(arr_x_lineaF, arr_y_lineaF)
  sigma_xy = np.sum(xy_mult)

  matriz_imprimir_lineaF = ([[n, sigma_x, sigma_x_fun, sigma_y], [sigma_x, sigma_x_cuadrada, sigma_x_porfunx, sigma_xy], [sigma_x_fun, sigma_x_porfunx, sigma_x2_fun, sigma_yporfunx]])
  print("Los coeficientes de la matriz son: ")
  print(matriz_imprimir_lineaF)
  matriz_coef = matriz_imprimir_lineaF.copy()
  matriz_coef = np.delete(matriz_coef, 3, 1)
  matriz_gx = matriz_imprimir_lineaF.copy()
  matriz_gx = np.delete(matriz_gx, [0,2],1)

  soluciones = np.linalg.solve(matriz_coef, matriz_gx)
  a_0 = soluciones[0][1]
  a_1 = soluciones[1][1]
  a_2 = soluciones[2][1]

  if a_0 < 1e-8:
      a_0 = 0
  elif a_1 < 1e-8:
      a_1 = 0
  elif a_2 < 1e-8:
      a_2 = 0

  print("El valor de a0 es: " + str(a_0))
  print("El valor de a1 es: " + str(a_1))
  print("El valor de a2 es: " + str(a_2))
  nuevos_linF = []
  for x_vieja in arr_x_lineaF:
      elemento = a_0 + (a_1*x_vieja) + (a_2*(funcion_np_usar(x_vieja)))
      nuevos_linF.append(elemento)

  for i in range(n):
      val_x_nueva = nuevos_linF[i]
      print("El valor de x" + str(i+1) + " ajustada con g(x) es:", val_x_nueva)
  fig4,ax4=plt.subplots()
  ax4.plot(arr_x_lineaF, arr_y_lineaF, 'bo', label= 'Valores originales') #puntos viejos
  ax4.plot(nuevos_linF, arr_y_lineaF, 'ro', label='Valores ajustados') #puntos nuevos
  ax4.plot(nuevos_linF, arr_y_lineaF, color='red',linewidth=1.2) #linea nueva
  ax4.plot(arr_x_lineaF, arr_y_lineaF, color='blue',linewidth=1.2) #linea vieja
  ax4.set_title('Mínimos Cuadrados con Lineal con función', fontsize=18)
  ax4.set_xlabel('x', fontsize=15)
  ax4.set_ylabel('y', fontsize=15)
  ax4.legend(markerfirst=False)
  fig4.show();
except:
  output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")

"""## Cuadrática con Función

### ¿Cómo funciona?

Los mínimos cuadrados por cuadrática con función intentan ajustar una función cuadrática en conjunto con una función a escoger, a varios puntos $(x_1,y_1),(x_2,y_2), ... (x_n, y_n)$ usando la ecuación $g(x) = a_0 + a_1x + a_2x^2 + a_3x$* función$(x)$

Las funciones que se pueden usar son: $e^x$, $sin(x), cos(x), tan(x), ln(x)$, etcétera.

$a_0, a_1, a_2, a_3$ representan coeficientes de la intersección de la pendiente de la línea con el eje $x$

Para obtener los coeficientes y a $g(x)$ es necesario trabajar con una matriz de la siguiente manera:

$$\left( \begin{matrix} a_0 & a_1x & a_2x^2 & a_3f(x) & g(x) \\ n & \Sigma x & \Sigma x^2 &  \Sigma f(x) & \Sigma y \\ \Sigma x & \Sigma x^2 & \Sigma x^3 & \Sigma xf(x) & \Sigma xy \\ \Sigma x^2 & \Sigma x^3 & \Sigma x^4 & \Sigma x^2f(x) & \Sigma x^2y \\ \Sigma f(x) & \Sigma xf(x) & \Sigma x^2f(x) & \Sigma f(x^2) &  \Sigma yf(x) \end{matrix} \right) $$

Donde n es el número de valores a ajustar, y $\Sigma$ representa la sumatoria de los valores.
### ¿Cómo se puede usar?

Para usar este método, hay que ejecutar la **celda** de código siguiente e ingresar primero el valor de $n$, posteriormente los valores de $x_1 ... x_n$ y los valores de $y_1 ... y_n$
"""

#@title Calculadora para mínimos cuadrados con cuadratica con función
try:
  x, y, z = sp.symbols("x y z")
  n = int(input("Ingrese el número de valores de x: "))
  arr_x_cuadF = []
  for i in range(n):
      val_x = float(input("Ingrese el valor de " + "x" + str(i+1) +": "))
      arr_x_cuadF.append(val_x)
  arr_y_cuadF = []
  for i in range(n):
      val_y = float(input("Ingrese el valor de " + "y" + str(i+1) +": "))
      arr_y_cuadF.append(val_y)
  print("\nValores de x: ")
  print(arr_x_cuadF)
  print("\nValores de y: ")
  print(arr_y_cuadF)


  dict_funciones = {'1': 'e^x', '2': 'sin(x)', '3': 'cos(x)', '4': 'tan(x)', '5':'ln(x)'}
  for funcion in dict_funciones.values():
      display(Math(funcion))

  decision = input("Ingrese el número de la función que desea usar")
  dict_funciones['1'] = 'exp(x)'
  dict_funciones['5'] = 'log(x)'
  funcion_usar = dict_funciones.get(decision)
  funcion_sim_usar = sp.sympify(funcion_usar)
  funcion_np_usar = sp.lambdify(x, funcion_sim_usar, 'numpy')

  sigma_x = np.sum(arr_x_cuadF)
  sigma_y = np.sum(arr_y_cuadF)
  x_cuadrada = np.power(arr_x_cuadF, 2)
  sigma_x_cuadrada = np.sum(x_cuadrada)
  x_cubica = np.power(arr_x_cuadF, 3)
  sigma_x_cubica = np.sum(x_cubica)
  x_cuarta = np.power(arr_x_cuadF, 4)
  sigma_x_cuarta = np.sum(x_cuarta)
  x_funcion = funcion_np_usar(arr_x_cuadF)
  sigma_x_fun = np.sum(x_funcion)
  x2_funcion = funcion_np_usar(x_cuadrada)
  sigma_x2_fun = np.sum(x2_funcion)
  x_por_funcionx = np.multiply(arr_x_cuadF, x_funcion)
  sigma_x_porfunx = np.sum(x_por_funcionx)
  y_por_funcion_x = np.multiply(arr_y_cuadF, x_funcion)
  sigma_yporfunx = np.sum(y_por_funcion_x)
  x2_ymult = np.multiply(x_cuadrada, arr_y_cuadF)
  sigma_x2y = np.sum(x2_ymult)
  x2_por_fx = np.multiply(x_cuadrada, x_funcion)
  sigma_x2_por_fx = np.sum(x2_por_fx)
  xy_mult = np.multiply(arr_x_cuadF, arr_y_cuadF)
  sigma_xy = np.sum(xy_mult)

  matriz_imprimir_cuadF = ([[n, sigma_x, sigma_x_cuadrada, sigma_x_fun, sigma_y], 
      [sigma_x, sigma_x_cuadrada, sigma_x_cubica, sigma_x_porfunx, sigma_xy], 
      [sigma_x_cuadrada, sigma_x_cubica, sigma_x_cuarta, sigma_x2_por_fx, sigma_x2y],
      [sigma_x_fun, sigma_x_porfunx, sigma_x2_por_fx, sigma_x2_fun, sigma_yporfunx]])
  print("Los coeficientes de la matriz son: ")
  print(matriz_imprimir_cuadF)
  matriz_coef = matriz_imprimir_cuadF.copy()
  matriz_coef = np.delete(matriz_coef, 4, 1)
  matriz_gx = matriz_imprimir_cuadF.copy()
  matriz_gx = np.delete(matriz_gx, [0,3],1)

  soluciones = np.linalg.solve(matriz_coef, matriz_gx)
  a_0 = soluciones[0][2]
  a_1 = soluciones[1][2]
  a_2 = soluciones[2][2]
  a_3 = soluciones[3][2]

  if a_0 < 1e-8:
      a_0 = 0
  elif a_1 < 1e-8:
      a_1 = 0
  elif a_2 < 1e-8:
      a_2 = 0
  elif a_3 < 1e-8:
      a_3 = 0


  print("El valor de a0 es: " + str(a_0))
  print("El valor de a1 es: " + str(a_1))
  print("El valor de a2 es: " + str(a_2))
  print("El valor de a3 es: " + str(a_3))
  nuevos_cuadF = []
  for x_vieja in arr_x_cuadF:
      elemento = a_0 + (a_1*x_vieja) + (a_2*(np.power(x_vieja,2))) + (a_3*funcion_np_usar(x_vieja))
      nuevos_cuadF.append(elemento)

  for i in range(n):
      val_x_nueva = nuevos_cuadF[i]
      print("El valor de x" + str(i+1) + " ajustada con g(x) es:", val_x_nueva)
  fig5,ax5=plt.subplots()
  ax5.plot(arr_x_cuadF, arr_y_cuadF, 'bo', label= 'Valores originales') #puntos viejos
  ax5.plot(nuevos_cuadF, arr_y_cuadF, 'ro', label='Valores ajustados') #puntos nuevos
  ax5.plot(nuevos_cuadF, arr_y_cuadF, color='red',linewidth=1.2) #linea nueva
  ax5.plot(arr_x_cuadF, arr_y_cuadF, color='blue',linewidth=1.2) #linea vieja
  ax5.set_title('Mínimos Cuadrados con Cuadrática con función', fontsize=18)
  ax5.set_xlabel('x', fontsize=15)
  ax5.set_ylabel('y', fontsize=15)
  ax5.legend(markerfirst=False)
  fig5.show();
except:
  output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")

"""<a name="section6"></a>
# Integración Numérica

## ¿Qué es?

La integración numérica consiste en el uso de diversos algoritmos creados para calcular el valor numérico de una integral definida, existen múlitples razones para preferir el uso de la integración numérica a una solución analítica. La principal puede ser la imposibilidad de realizar la integración de forma analítica. Es decir, integrales que requerirían de un gran conocimiento y manejo de matemática avanzada pueden ser resueltas de una manera más sencilla mediante métodos numéricos. Incluso existen funciones integrables pero cuya primitiva no puede ser calculada, siendo la integración numérica de vital importancia. La solución analítica de una integral proporciona una solución exacta, mientras que la solución numérica tendría como salida una solución aproximada.

## ¿Cuál es su solución?

Para que un problema de integración numérica se considere resuelto, se tiene que obtener una aproximación al resultado de la integración definida de una función de un límite superior a un límite inferior. Esta aproximación se obtiene aplicando distintos métodos numéricos, en este caso se usarán los siguientes:
   * Regla trapezoidal
   * Newton Cotes Cerradas
   * Newton Cotes Abiertas
   * Regla de $\dfrac{1}{3}$ de Simpson 
   * Regla de $\dfrac{3}{8}$ de Simpson
"""

# Commented out IPython magic to ensure Python compatibility.
# #@title Ejecutar esta celda para comenzar a trabajar con integración numérica
# %%capture
# from google.colab import output
# !pip install ipympl
# %matplotlib widget
# import numpy as np
# import matplotlib.pyplot as plt
# import sys
# import sympy as sp
# sp.init_printing(use_latex='mathjax')
# from IPython.display import Math,display

"""## Regla trapezoidal:

### ¿Cómo funciona?
La regla se basa en aproximar el valor de la integral de $f(x)$ por el de la función lineal, que pasa a través de los puntos $(a,f(a))$ y $(b,f(b))$. La integral de ésta es igual al área del trapecio bajo la gráfica de la función lineal. Se tienen que usar polinomios de primer grado.

Su fórmula es:

$I = \dfrac{h}{2} \left(f(a)+2\sum_{i=1}^{n-1}f(a+ih)+f(b)\right)$

Donde la integral a integrar se define como:

$\int_{a}^{b} f(x) \,dx$

Para calcular el valor de $h$, se usa la fórmula $h = \dfrac{b-a}{n}$

### ¿Cómo se puede utilizar?

Para usar este método, primero hay que ingresar la función a integrar.
El formato de funciones aceptado en esta libreta es el siguiente:
   * Para representar productos $3x$ hay que ingresar ```3*x```
   * Para representar funciones trigonométricas $sen(x)$ hay que usar ```sin(x)```, las demás permanecen igual
   * Para representar exponenciales $e^x$ hay que usar ```exp(x)```
   * Para representar potencias $x^2$ hay que usar ```x^2```
   
Un ejemplo de una ecuación ingresada sería $3x-sin(x)+e^x$ es: ```3*x -sin(x)+exp(x)```

Después de ingresar la función, hay que ingresar el límite superior a evaluar que se representa como $a$ y el límite inferior a evaluar que se representa como $b$. Posterior a eso, se ingresa el número de subintervalos del trapezio, representado con la variable $n$. Finalmente, el método mostrará el resultado de la aproximación
"""

#@title Calcular por regla trapezoidal
try:
  import numpy as np
  #la función de la integral "buena"
  #TODO: MOSTRAR CALCULOS INTERNOS
  #definimos la funcion de la integral a la que le pasaremos la n
  def integral_iterar(integral,a,b,n):
      #calculamos h
      h = (b-a)/n
      #calculamos el valor de afuera, es decir 3/8 por h
      afuera = h/2
      primer_termino = integral(a) #el primer termino de 3/8 siempre es f(a)
      #el segundo termino es 3 multiplicado por la suma de f de i hasta n-1
      #guardaremos cada resultado de f de i hasta n - 1 en el array de terminos_sumatoria
      terminos_sumatoria = []
      #desde i = 1 hasta n-1
      #es decir 1,2,3,4 si n vale 5
      for i in range (1,n):
          #obtener el valor de ih
          i_h = i*h
          #obtener el valor de a +ih
          a_sumada = a + i_h
          #aplicar a la integral el valor de a_sumada
          termino_suma = integral(a_sumada)
          #guardar en el array el resultado de la integral
          terminos_sumatoria.append(termino_suma)
      #una vez que llega hasta n-1, multiplica por 3 todos los resultados
      segundo_termino_sin_sumar = np.multiply(2, terminos_sumatoria)
      #luego suma todos los resultados y los guarda en el segundo término
      segundo_termino_sumado = np.sum(segundo_termino_sin_sumar)
      #el tercer término es siempre f(b)
      tercer_termino = integral(b)
      #suma el primero mas el segundo mas el tercero
      suma_interna = primer_termino + segundo_termino_sumado + tercer_termino
      #mulitplica por lo de afuera a la suma
      resultado = afuera * suma_interna
      #retorna el resultado
      return resultado
  x, y, z = sp.symbols("x y z")
  funcion_string = input("Ingrese la función a integrar")
  funcion_sp = sp.sympify(funcion_string)
  display(Math(sp.latex(funcion_sp)))
  funcion_integrar_np = sp.lambdify(x,funcion_sp, "numpy")
  a = float(input("Ingrese el límite inferior del rango de evaluación"))
  b = float(input("Ingrese el límite superior del rango de evaluación"))
  n = int(input("Ingrese el número de subintervalos de la integral"))
  if ((n%2) == 0):
    output.clear()
    print("\nn siempre debe de ser impar")
    raise SystemExit
  resultado = integral_iterar(funcion_integrar_np,a,b,n )
  #cambiar el nombre de la función
  print("El resultado de la integral es: ",resultado)
except:
  #output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")

"""## Newton Cotes Cerradas:

### ¿Cómo funciona?

La ecuación usa las fórmulas de Newton-Cotes, al ser la función cerrada se usa la fórmula:

$I = \alpha h\sum_{i=0}^{n}wif(a+ih)$

Donde la integral a integrar se define como:

$\int_{a}^{b} f(x) \,dx$

Para calcular el valor de $h$, se usa la fórmula $h = \dfrac{b-a}{n}$

El coeficiente $\alpha$ se determina de la tabla de coeficientes por fórmula cerrada

### ¿Cómo se puede utilizar?

Para usar este método, primero hay que ingresar la función a integrar.
El formato de funciones aceptado en esta libreta es el siguiente:
   * Para representar productos $3x$ hay que ingresar ```3*x```
   * Para representar funciones trigonométricas $sen(x)$ hay que usar ```sin(x)```, las demás permanecen igual
   * Para representar exponenciales $e^x$ hay que usar ```exp(x)```
   * Para representar potencias $x^2$ hay que usar ```x^2```
   
Un ejemplo de una ecuación ingresada sería $3x-sin(x)+e^x$ es: ```3*x -sin(x)+exp(x)```

Después de ingresar la función, hay que ingresar el límite superior a evaluar que se representa como $a$ y el límite inferior a evaluar que se representa como $b$. Posterior a eso, se ingresa el número de subintervalos del trapezio, representado con la variable $n$. Finalmente, el método mostrará el resultado de la aproximación
"""

#@title Calculadora para Newton Cotes Cerradas
try:
  def newton_cerradas(funcion_integrar, a,b,n):
      dic_alfas = {1:1/2, 2:1/3, 3:3/8, 4:2/45, 5:2/288, 6:1/140,7:7/17280,8:14/14175,9:9/89600,10:5/299376}
      alfa = dic_alfas.get(n)
      dic_n1 = {0:1,1:1}
      dic_n2 = {0:1,1:4,2:1}
      dic_n3 = {0:1,1:3,2:3,3:1}
      dic_n4 = {0:7,1:32,2:12,3:32,4:7}
      dic_n5 = {0:19,1:75,2:50,3:50,4:75,5:19}
      dic_n6 = {0:41,1:216,2:27,3:272,4:27,5:216,6:41}
      dic_n7 = {0:751,1:3577,2:1323,3:2989,4:2989,5:1323,6:3577,7:751}
      dic_n8 = {0:989,1:5888,2:-928,3:10946,4:-4540,5:10946,6:-928,7:5888,8:989}
      dic_n9 = {0:2857,1:15741,2:1080,3:19344,4:5788,5:5788,6:19344,7:1080,8:15741,9:2857}
      dic_n10 = {0:16067,1:106300,2:-48525,3:272400,4:-260550,5:427368,6:-260550,7:272400,8:-48525,9:106300,10:16067}
      dic_constantes = {1:dic_n1,2:dic_n2,3:dic_n3,4:dic_n4,5:dic_n5,6:dic_n6,7:dic_n7,8:dic_n8,9:dic_n9,10:dic_n10}
      constantes = dic_constantes.get(n)
      
      h = (b-a)/n
      afuera = alfa * h
      print("h: ",h)
      print("alfa: ",alfa)
      sumatoria_terminos = []
      
      for i in range(0,n+1):
          wi = constantes.get(i)
          ih = i*h
          a_ih = a+ih
          resultado_parcial = funcion_integrar(a_ih)
          completo = wi * resultado_parcial
          print("Término de i = " + str(i) + ": ", completo)
          sumatoria_terminos.append(completo)
      
      suma_interna = np.sum(sumatoria_terminos)
      print("Suma interna: ",suma_interna)
      resultado = afuera * suma_interna
      return resultado


  x, y, z = sp.symbols("x y z")
  funcion_string = input("Ingrese la función a integrar")
  funcion_sp = sp.sympify(funcion_string)
  display(Math(sp.latex(funcion_sp)))
  funcion_integrar_np = sp.lambdify(x,funcion_sp, "numpy")
  a = float(input("Ingrese el límite inferior del rango de evaluación"))
  b = float(input("Ingrese el límite superior del rango de evaluación"))
  n = int(input("Ingrese el número de subintervalos de la integral"))

  resultado = newton_cerradas(funcion_integrar_np, a,b,n)
  print("El resultado de la integral es: ", resultado)
except:
  output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")

"""## Newton Cotes Abiertas

### ¿Cómo funciona?

La ecuación usa las fórmulas de Newton-Cotes, al ser la función abierta se usa la fórmula:

$I = \alpha h\sum_{i=0}^{n+2}wif(a+ih)$

Donde la integral a integrar se define como:

$\int_{a}^{b} f(x) \,dx$

Para calcular el valor de $h$, se usa la fórmula $h = \dfrac{b-a}{n+2}$

El coeficiente $\alpha$ se determina de la tabla de coeficientes por fórmula abierta


### ¿Cómo se puede utilizar?

Para usar este método, primero hay que ingresar la función a integrar.
El formato de funciones aceptado en esta libreta es el siguiente:
   * Para representar productos $3x$ hay que ingresar ```3*x```
   * Para representar funciones trigonométricas $sen(x)$ hay que usar ```sin(x)```, las demás permanecen igual
   * Para representar exponenciales $e^x$ hay que usar ```exp(x)```
   * Para representar potencias $x^2$ hay que usar ```x^2```
   
Un ejemplo de una ecuación ingresada sería $3x-sin(x)+e^x$ es: ```3*x -sin(x)+exp(x)```

Después de ingresar la función, hay que ingresar el límite superior a evaluar que se representa como $a$ y el límite inferior a evaluar que se representa como $b$. Posterior a eso, se ingresa el número de subintervalos del trapezio, representado con la variable $n$. Finalmente, el método mostrará el resultado de la aproximación
"""

#@title Calculadora para Newton Cotes Cerradas
try:
  def newton_abiertas(funcion_integrar, a,b,n):
      dic_alfas = {1:3/2, 2:4/3, 3:5/24, 4:6/20, 5:7/1440, 6:8/945}
      alfa = dic_alfas.get(n)
      dic_n1 = {0:0,1:1,2:1,3:0}
      dic_n2 = {0:0,1:2,2:-1,3:2,4:0}
      dic_n3 = {0:0,1:11,2:1,3:1,4:11,5:0}
      dic_n4 = {0:0,1:11,2:-14,3:26,4:-14,5:11,6:0}
      dic_n5 = {0:0,1:611,2:-453,3:562,4:562,5:-453,6:611,7:0}
      dic_n6 = {0:0,1:460,2:-954,3:2196,4:-2459,5:2196,6:-954,7:460,8:0}
      dic_constantes = {1:dic_n1,2:dic_n2,3:dic_n3,4:dic_n4,5:dic_n5,6:dic_n6}
      constantes = dic_constantes.get(n)
      
      h = (b-a)/(n+2)
      afuera = alfa * h
      print("h: ",h)
      print("alfa: ",alfa)
      sumatoria_terminos = []
      
      for i in range(0,n+3):
          wi = constantes.get(i)
          ih = i*h
          a_ih = a+ih
          resultado_parcial = funcion_integrar(a_ih)
          completo = wi * resultado_parcial
          print("Término de i = " + str(i) + ": ", completo)
          sumatoria_terminos.append(completo)
      
      suma_interna = np.sum(sumatoria_terminos)
      print("Suma interna: ", suma_interna)
      resultado = afuera * suma_interna
      return resultado


  x, y, z = sp.symbols("x y z")
  funcion_string = input("Ingrese la función a integrar")
  funcion_sp = sp.sympify(funcion_string)
  display(Math(sp.latex(funcion_sp)))
  funcion_integrar_np = sp.lambdify(x,funcion_sp, "numpy")
  a = float(input("Ingrese el límite inferior del rango de evaluación"))
  b = float(input("Ingrese el límite superior del rango de evaluación"))
  n = int(input("Ingrese el número de subintervalos de la integral"))

  resultado = newton_abiertas(funcion_integrar_np, a,b,n)
  print("El resultado de la integral es: ", resultado)
except:
  output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")

"""## Regla de $\dfrac{1}{3}$ de Simpson

### ¿Cómo funciona?

Se obtiene al interpolar un polinomio de $2^o$ grado.
Se usa la fórmula:

$I = \dfrac{h}{3} f(a) + 4\sum_{i=1}^{n-1}f(a+ih)+2\sum_{i=2}^{n-2}f(a+ih)+f(b)$

Donde la integral a integrar se define como:

$\int_{a}^{b} f(x) \,dx$

El número de subintervalos $n$ tiene que ser par siempre.

Para calcular el valor de $h$, se usa la fórmula $h = \dfrac{b-a}{n}$

El coeficiente $\alpha$ se determina de la tabla de coeficientes por fórmula abierta


### ¿Cómo se puede utilizar?

Para usar este método, primero hay que ingresar la función a integrar.
El formato de funciones aceptado en esta libreta es el siguiente:
   * Para representar productos $3x$ hay que ingresar ```3*x```
   * Para representar funciones trigonométricas $sen(x)$ hay que usar ```sin(x)```, las demás permanecen igual
   * Para representar exponenciales $e^x$ hay que usar ```exp(x)```
   * Para representar potencias $x^2$ hay que usar ```x^2```
   
Un ejemplo de una ecuación ingresada sería $3x-sin(x)+e^x$ es: ```3*x -sin(x)+exp(x)```

Después de ingresar la función, hay que ingresar el límite superior a evaluar que se representa como $a$ y el límite inferior a evaluar que se representa como $b$. Posterior a eso, se ingresa el número de subintervalos de la función, representado con la variable $n$. Finalmente, el método mostrará el resultado de la aproximación
"""

#@title Calculadora para Regla de 1/3 de Simpson
try:
  import numpy as np
  #la función de la integral "buena"

  #definimos la funcion de la integral a la que le pasaremos la n
  def simpson_13(integral,a,b,n):
      #calculamos h
      h = (b-a)/n
      print("h: ",h)
      #calculamos el valor de afuera, es decir 3/8 por h
      afuera = h/3
      primer_termino = integral(a) #el primer termino de 3/8 siempre es f(a)
      print("Primer término f(a) : ",primer_termino)
      #el segundo termino es 3 multiplicado por la suma de f de i hasta n-1
      #guardaremos cada resultado de f de i hasta n - 1 en el array de terminos_sumatoria
      terminos_sumatoria_4 = []
      #desde i = 1 hasta n-1
      #es decir 1,2,3,4 si n vale 5
      print("Calculando los terminos de la primera sumatoria: ")
      for i in range (1,n):
          if i%2 !=0:
              #obtener el valor de ih
              i_h = i*h
              #obtener el valor de a +ih
              a_sumada = a + i_h
              #aplicar a la integral el valor de a_sumada
              termino_suma = integral(a_sumada)
              print("Término de i = " + str(i) + "para el valor de a+ih: ",a_sumada," : ",termino_suma)
              #guardar en el array el resultado de la integral
              terminos_sumatoria_4.append(termino_suma)
      #una vez que llega hasta n-1, multiplica por 3 todos los resultados
      suma_de4 = np.sum(terminos_sumatoria_4)
      #luego suma todos los resultados y los guarda en el segundo término
      suma_por4 = np.multiply(suma_de4,4)
      #TODO: Darle vista bonita con latex
      print("El resultado de 4sigma es: ", suma_por4)
      
      terminos_sumatoria_2 = []
      #desde i = 1 hasta n-1
      #es decir 1,2,3,4 si n vale 5
      print("Calculando los terminos de la primera sumatoria: ")
      for i in range (2,n-1):
          if i%2==0:
              #obtener el valor de ih
              i_h = i*h
              #obtener el valor de a +ih
              a_sumada = a + i_h
              #aplicar a la integral el valor de a_sumada
              termino_suma = integral(a_sumada)
              print("Término de i = " + str(i) + "para el valor de a+ih: ",a_sumada," : ",termino_suma)
              #guardar en el array el resultado de la integral
              terminos_sumatoria_2.append(termino_suma)
      #una vez que llega hasta n-1, multiplica por 3 todos los resultados
      suma_de2 = np.sum(terminos_sumatoria_2)
      #luego suma todos los resultados y los guarda en el segundo término
      suma_por2 = np.multiply(suma_de2, 2)
      #TODO: Darle vista bonita con latex
      print("El resultado de 2sigma es: ", suma_por2)
      
      segundo_termino= suma_por4 + suma_por2
      
      tercer_termino = integral(b)
      print("Tercer término f(b) : ",tercer_termino)

      #suma el primero mas el segundo mas el tercero
      suma_interna = primer_termino + segundo_termino + tercer_termino
      #mulitplica por lo de afuera a la suma
      print("Suma interna: ", suma_interna)
      resultado = afuera * suma_interna
      #retorna el resultado
      return resultado
  x, y, z = sp.symbols("x y z")
  funcion_string = input("Ingrese la función a integrar")
  funcion_sp = sp.sympify(funcion_string)
  display(Math(sp.latex(funcion_sp)))
  funcion_integrar_np = sp.lambdify(x,funcion_sp, "numpy")
  a = float(input("Ingrese el límite inferior del rango de evaluación"))
  b = float(input("Ingrese el límite superior del rango de evaluación"))
  n = int(input("Ingrese el número de subintervalos de la integral"))
  if ((n%2) != 0):
    output.clear()
    print("\nn siempre debe de ser par")
    raise SystemExit
  resultado = simpson_13(funcion_integrar_np,a,b,n )
  #cambiar el nombre de la función
  print("El resultado de la integral es: ",resultado)
except:
  #output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")

"""## Regla de $\dfrac{3}{8}$ de Simpson:

### ¿Cómo funciona?

Se obtiene al interpolar un polinomio de $2^o$ grado, multiplicando al factor $h$ por $\dfrac{3}{8}$.

Se usa la fórmula:

$I = \dfrac{3h}{8} f(a) + 3\sum_{i=1}^{n-1}f(a+ih)+f(b)$

Donde la integral a integrar se define como:

$\int_{a}^{b} f(x) \,dx$

El número de subintervalos $n$ tiene que ser impar siempre.

Para calcular el valor de $h$, se usa la fórmula $h = \dfrac{b-a}{n}$

El coeficiente $\alpha$ se determina de la tabla de coeficientes por fórmula abierta


### ¿Cómo se puede utilizar?

Para usar este método, primero hay que ingresar la función a integrar.
El formato de funciones aceptado en esta libreta es el siguiente:
   * Para representar productos $3x$ hay que ingresar ```3*x```
   * Para representar funciones trigonométricas $sen(x)$ hay que usar ```sin(x)```, las demás permanecen igual
   * Para representar exponenciales $e^x$ hay que usar ```exp(x)```
   * Para representar potencias $x^2$ hay que usar ```x^2```
   
Un ejemplo de una ecuación ingresada sería $3x-sin(x)+e^x$ es: ```3*x -sin(x)+exp(x)```

Después de ingresar la función, hay que ingresar el límite superior a evaluar que se representa como $a$ y el límite inferior a evaluar que se representa como $b$. Posterior a eso, se ingresa el número de subintervalos de la función, representado con la v
"""

#@title Calculadora para Regla de 3/8 de Simpson
try:
  import numpy as np
  #la función de la integral "buena"

  #definimos la funcion de la integral a la que le pasaremos la n
  def simpson_38(integral,a,b,n):
      #calculamos h
      h = (b-a)/n
      print("h: ",h)
      #calculamos el valor de afuera, es decir 3/8 por h
      afuera = h * (3/8)
      primer_termino = integral(a) #el primer termino de 3/8 siempre es f(a)
      print("Primer término f(a) : ",primer_termino)
      #el segundo termino es 3 multiplicado por la su
      
      terminos_sumatoria = []
      #desde i = 1 hasta n-1
      #es decir 1,2,3,4 si n vale 5
      print("Calculando los terminos de la primera sumatoria: ")
      for i in range (1,n):
          #obtener el valor de ih
          i_h = i*h
          #obtener el valor de a +ih
          a_sumada = a + i_h
          #aplicar a la integral el valor de a_sumada
          termino_suma = integral(a_sumada)
          print("Término de i = " + str(i) + "para el valor de a+ih: ",a_sumada," : ",termino_suma)
          #guardar en el array el resultado de la integral
          terminos_sumatoria.append(termino_suma)
      #una vez que llega hasta n-1, multiplica por 3 todos los resultados
      suma = np.sum(terminos_sumatoria)
      #luego suma todos los resultados y los guarda en el segundo término
      suma_por3 = np.multiply(suma,3)
      #TODO: Darle vista bonita con latex
      print("El resultado de 3sigma es: ", suma_por3)
      tercer_termino = integral(b)
      print("Tercer término f(b) : ",tercer_termino)

      #suma el primero mas el segundo mas el tercero
      suma_interna = primer_termino + suma_por3 + tercer_termino
      #mulitplica por lo de afuera a la suma
      print("Suma interna: ", suma_interna)
      resultado = afuera * suma_interna
      #retorna el resultado
      return resultado
  x, y, z = sp.symbols("x y z")
  funcion_string = input("Ingrese la función a integrar")
  funcion_sp = sp.sympify(funcion_string)
  display(Math(sp.latex(funcion_sp)))
  funcion_integrar_np = sp.lambdify(x,funcion_sp, "numpy")
  a = float(input("Ingrese el límite inferior del rango de evaluación"))
  b = float(input("Ingrese el límite superior del rango de evaluación"))
  n = int(input("Ingrese el número de subintervalos de la integral"))
  if ((n%2) == 0):
    output.clear()
    print("\nn siempre debe de ser impar")
    raise SystemExit
  resultado = simpson_38(funcion_integrar_np,a,b,n )
  #cambiar el nombre de la función
  print("El resultado de la integral es: ",resultado)
except:
  #output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")

"""<a name="section7"></a>
# Ecuaciones Diferenciales Ordinarias

## ¿Qué son?

Son ecuaciones compuestas por: una función desconocida y derivadas.
La clasificación de las mismas en los problemas depende:
* Condiciones iniciales. Los problemas con condiciones iniciales estos dependen
del tiempo, es decir, sus condiciones iniciales se basan en el tiempo inicial para
la solución.
* Condiciones en la frontera. Son diferentes los métodos numéricos en forma
significativa de los que se usa para problemas con condiciones iniciales.

## ¿Cuál es su solución?

Dependiendo del método, se tiene que encontrar el valor de $y_1$ y de $y_2$ en una condición inicial.
"""

# Commented out IPython magic to ensure Python compatibility.
# #@title Ejecutar esta celda para comenzar a trabajar con los métodos para resolver Ecuaciones Diferenciales Ordinarias
# %%capture
# from google.colab import output
# !pip install ipympl
# %matplotlib widget
# import numpy as np
# from numpy.linalg import norm
# import sympy as sp
# import matplotlib.pyplot as plt
# from scipy.optimize import fsolve
# from mpmath import findroot
# from IPython.display import Math,display
# sp.init_printing(use_latex='mathjax')
# import warnings
# import math
# import ipywidgets as widgets
# #warnings.filterwarnings('error')
# np.seterr(all='print')

"""## Euler hacia Adelante

### ¿Cómo funciona?
Con la primera derivada se obtiene en forma directa la estimación de una pendiente.
La ecuación que lo describe es la siguiente:

$y_{n+1}= y_n+hf(y_n,t_n)$

Donde $t = 0$ debido a que parte del origen.


### ¿Cómo se puede utilizar?

Primeramente se debe ejecutar la celda siguiente para dar inicio a la calculadora de Euler hacia adelante. El segundo paso consiste en ingresa la ecuación despejada para $y'$ al igual que los valores para $y_0$ y $h$.   
"""

#@title Calcular con Euler hacia adelante
try:
  x, y, t = sp.symbols("x y t")
  fun = input('Ingrese la ecuación despejada para y\': ')
  fun_sim= sp.sympify(fun)
  display(Math(sp.latex(fun_sim)))
  y0 = float(input("Ingrese el valor de y0: "))
  h = float(input("Ingrese el valor de h: "))
  t0 = 0
  fun_np = sp.lambdify([y,t], fun_sim, 'numpy')
  resultado_y1 = fun_np(y0,t0)
  y1 = y0 + (h * resultado_y1)
  print("El valor de y1 es: ", y1)
  t1 = t0 + h
  resultado_y2 = fun_np(y1,t1)
  y2 = y1 + (h * resultado_y2)
  print("El valor de y2 es: ",y2)
except:
  output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")

"""## Euler hacia Atrás

###¿Cómo funciona?
Se basa en la aproximación de diferencias hacia atras.

la ecuación es la siguiente:

$y_{n+1}= y_n+hf(y_{n+1},t_{n+1})$

$t=0$, debido a que parte del origen.

Se calcula $y_{n+1}$ de forma recursiva.
###¿Cómo se puede utilizar?
Al iniciar la calculadora el usuario es responsable de ingresar la función despejada para $y'$ asi como los valores $y_0$ y $h$, posteriormente se muestra el resultado.
"""

#@title calcular con Euler hacia atras
try:
  x, y, t = sp.symbols("x y t")
  fun1 = input('Ingrese la ecuación despejada para y\': ')
  fun_sim1= sp.sympify(fun1)
  display(Math(sp.latex(fun_sim1)))
  y0 = float(input("Ingrese el valor de y0: "))
  h = float(input("Ingrese el valor de h: "))
  t0 = 0
  yn_1 = y0

  fun_np = sp.lambdify([y,t], fun_sim1, 'numpy')
  resultado_y1 = fun_np(yn_1,t0)
  y1 = yn_1 + (h * resultado_y1)
  print("El valor de y1 es: ", y1)
  t1 = t0 + h
  resultado_y2 = fun_np(y1,t1)
  y2 = y1 + (h * resultado_y2)
  print("El valor de y2 es: ",y2)
except:
  output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")

"""## Euler Modificado
###¿Cómo funciona?
Este método es mas exacto que el de Euler hacia adelante

Las fórmulas son las siguientes:

 $y_{n+1}= y_n+\frac{h}{2}(f(y_n,t_n)+ f(y_{n+1},t_{n+1}))$

 $y'_1= y_0+\frac{h}{2}(f(y_0,t_0)+ f(y_{1},t_{1}))$
###¿Cómo se puede utilizar?
Primeramente se debe ejecutar la celda siguiente para dar inicio a la calculadora de Euler hacia adelante. El segundo paso consiste en ingresa la ecuación despejada para $y'$ al igual que los valores para $y_0$ y $h$.
"""

#@title calcular con Euler Modificado
try:
  x, y, t = sp.symbols("x y t")
  fun = input('Ingrese la ecuación despejada para y\': ')
  fun_sim= sp.sympify(fun)
  display(Math(sp.latex(fun_sim)))
  y0 = float(input("Ingrese el valor de y0: "))
  y1 = float(input("Ingrese el valor de y1: "))
  h = float(input("Ingrese el valor de h: "))
  t0 = 0
  t1 = t0 + h
  fun_np = sp.lambdify([y,t], fun_sim, 'numpy')
  resultado_yn = fun_np(y0,t0)
  resultado_yn1 = fun_np(y1,t1)
  y1prima = y0 + ((h/2) * (resultado_yn + resultado_yn1))
  print("El valor de y\'1 es: ", y1prima)
  t0 = t0 + h
  t1 = t0 + h
  y0 = y1
  y1 = y1prima
  resultado_yn = fun_np(y0,t0)
  resultado_yn1 = fun_np(y1,t1)
  y2prima = y0 + ((h/2) * (resultado_yn + resultado_yn1))
  print("El valor de y\'2 es: ",y2prima)
except:
  output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")

"""##Métodos de Runge - Kutta

###¿Qué son ?

Son una colección de metodos que se utilizan para resolver problemas de valor inicial sin utilizar el cálculo de derivadas de orden superior

son metodos iterativos implícitos y explícitos,para aproximar las soluciones de ecuaciones diferenciales ordinarias

####Método Runge-Kutta


*   $2^0$ orden
*   $3er.$ orden
*   $4to.$ orden por 
  *   $\frac{1}{3}$ de Simpson
  *   $\frac{3}{8}$ de Simpson
* Orden superior

## Runge Kutta $2^o$ orden
###¿Cómo funciona?
Se tienen dos pasos de iteración.

$k_1= hf(y_n,y_n)$

$k_2= hf(y_n+k_1,t_n+h)$

$y_{n+1}= y_n +\frac{1}{2}(k_1+k_2)$

k.- son relaciones de recurrencia
###¿Cómo se puede utilizar?
Al iniciar la calculadora el usuario es responsable de ingresar la función despejada para $y'$ asi como los valores $y_0$ y $h$, posteriormente se muestra el resultado.
"""

#@title calcular con Runge Kutta segundo orden
try:
  x, y, t = sp.symbols("x y t")
  fun = input('Ingrese la ecuación despejada para y\': ')
  fun_sim= sp.sympify(fun)
  display(Math(sp.latex(fun_sim)))
  y0 = float(input("Ingrese el valor de y0: "))
  h = float(input("Ingrese el valor de h: "))
  t0 = 0
  fun_np = sp.lambdify([y,t], fun_sim, 'numpy')
  k1 = h * (fun_np(y0,t0))
  yn_k1 = y0 + k1
  tn_h = t0 + h
  print(yn_k1)
  print(tn_h)
  resultado_f = fun_np(yn_k1, tn_h)
  print(resultado_f)
  k2 = h * resultado_f
  y_n1 = y0 + (0.5*(k1+k2))
  print("k1 para y1 : ",k1)
  print("k2 para y1: ",k2)
  print('El valor de y1 es: ',y_n1)
  y0 = y_n1
  t0 = t0 + h
  k1 = h * (fun_np(y0,t0))
  yn_k1 = y0 + k1
  tn_h = t0 + h
  k2 = h * (fun_np(yn_k1, tn_h))
  y_n2 = y0 + (0.5*(k1+k2))
  print("k1 para y2 : ",k1)
  print("k2 para y2: ",k2)
  print('El valor de y2 es: ',y_n1)
except:
  output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")

"""## Runge Kutta de $3^{er}$ orden

###¿Cómo funciona?
Las fórmulas son las siguientes:

$k_1= hf(y_n,y_n)$

$k_2= hf(y_n+\frac{k_1}{2},t_n+\frac{h}{2})$

$k_1= hf(y_n-k_1+2k,t_n+h)$

$y_{n+1}= y_n +\frac{1}{6}(k_1+4k_2+k_3)$
###¿Cómo se puede utilizar?
Al iniciar la calculadora el usuario es responsable de ingresar la función despejada para $y'$ asi como los valores $y_0$ y $h$, posteriormente se muestra el resultado.
"""

#@title calcular con Runge Kutta de tercer orden
try:
  x, y, t = sp.symbols("x y t")
  fun = input('Ingrese la ecuación despejada para y\': ')
  fun_sim= sp.sympify(fun)
  display(Math(sp.latex(fun_sim)))
  y0 = float(input("Ingrese el valor de y0: "))
  h = float(input("Ingrese el valor de h: "))
  t0 = 0
  fun_np = sp.lambdify([y,t], fun_sim, 'numpy')
  k1 = h * (fun_np(y0,t0))
  yn_k1 = y0 + (k1/2)
  tn_h2 = t0 + (h/2)
  resultado_f2 = fun_np(yn_k1, tn_h2)
  k2 = h * resultado_f2
  yn_k1_2k2 = y0 -k1 + (2*k2)
  tn_h = t0 + h
  resultado_f3 = fun_np(yn_k1_2k2, tn_h)
  k3 = h * resultado_f3
  y_n1 = y0 +((1/6)  * (k1 + (4*k2) + k3))
  print("k1 para y1 : ",k1)
  print("k2 para y1: ",k2)
  print("k3 para y1: ",k3)
  print('El valor de y1 es: ',y_n1)
  y0 = y_n1
  t0 = t0 + h
  k1 = h * (fun_np(y0,t0))
  yn_k1 = y0 + (k1/2)
  tn_h2 = t0 + (h/2)
  resultado_f2 = fun_np(yn_k1, tn_h2)
  k2 = h * resultado_f2
  yn_k1_2k2 = y0 -k1 + (2*k2)
  tn_h = t0 + h
  resultado_f3 = fun_np(yn_k1_2k2, tn_h)
  k3 = h * resultado_f3
  y_n2 = y0 +((1/6)  * (k1 + (4*k2) + k3))
  print("k1 para y2 : ",k1)
  print("k2 para y2: ",k2)
  print("k3 para y2: ",k3)
  print('El valor de y2 es: ',y_n2)
except:
  output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")

"""## Runge Kutta de $4^{to}$ orden por $\dfrac{1}{3}$ de Simpson
###¿Cómo funciona?
Utiliza múltiples estimaciones de la pendiente y así se obtiene un promedio de la
misma en el intervalo más exacto.
En este caso k representa la pendiente.

$k_1 = h f (y_n, t_n)$

$k_2 = h f (y_n+ k_1/2, t_n+ h/2)$

$k_3 = h f (y_n + k_2 /2, t_n+ h/2)$

$k_4 = h f (y_n + k_3, t_n+ h)$

$y_{n+1} = y_n +1/6 (k_1 + 2k_2 + 2k_3 + k_4)$


###¿Cómo se puede utilizar?

Primeramente se debe ejecutar la celda siguiente para dar inicio a la calculadora de Euler hacia adelante. El segundo paso consiste en ingresa la ecuación despejada para $y'$ al igual que los valores para $y_0$ y $h$.
"""

#@title Calcular con Runge Kutta de cuarto orden por 1/3 de Simpson
try:
  x, y, t = sp.symbols("x y t")
  fun = input('Ingrese la ecuación despejada para y\': ')
  fun_sim= sp.sympify(fun)
  display(Math(sp.latex(fun_sim)))
  y0 = float(input("Ingrese el valor de y0: "))
  h = float(input("Ingrese el valor de h: "))
  t0 = 0
  fun_np = sp.lambdify([y,t], fun_sim, 'numpy')
  k1 = h * (fun_np(y0,t0))
  yn_k2 = y0 + (k1/2)
  tn_h2 = t0 + (h/2)
  resultado_f2 = fun_np(yn_k2, tn_h2)
  k2 = h * resultado_f2
  yn_k3 = y0 +(k2/2)
  resultado_f3 = fun_np(yn_k3, tn_h2)
  k3 = h * resultado_f3
  yn_k4 = y0 + k3
  tn_h = t0 + h
  resultado_f4 = fun_np(yn_k4, tn_h)
  k4 = h * resultado_f4
  y_n1 = y0 +((1/6)  * (k1 + (2*k2) + (2*k3) + k4))
  print("k1 para y1 : ",k1)
  print("k2 para y1: ",k2)
  print("k3 para y1: ",k3)
  print("k4 para y1: ",k4)
  print('El valor de y1 es: ',y_n1)
  y0 = y_n1
  t0 = t0 + h
  k1 = h * (fun_np(y0,t0))
  yn_k2 = y0 + (k1/2)
  tn_h2 = t0 + (h/2)
  resultado_f2 = fun_np(yn_k2, tn_h2)
  k2 = h * resultado_f2
  yn_k3 = y0 +(k2/2)
  resultado_f3 = fun_np(yn_k3, tn_h2)
  k3 = h * resultado_f3
  yn_k4 = y0 + k3
  tn_h = t0 + h
  resultado_f4 = fun_np(yn_k4, tn_h)
  k4 = h * resultado_f4
  y_n2 = y0 +((1/6)  * (k1 + (2*k2) + (2*k3) + k4))
  print("k1 para y2 : ",k1)
  print("k2 para y2: ",k2)
  print("k3 para y2: ",k3)
  print("k4 para y2: ",k4)
  print('El valor de y2 es: ',y_n2)
except:
  output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")

"""## Runge Kutta de $4^{to}$ orden por $\dfrac{3}{8}$ de Simpson
###¿Cómo funciona?
$k_1 = h f (y_n, t_n)$

$k_2 = h f (y_n+ k_1/3, t_n+ h/3)$

$k_3 = h f (y_n + k_1 /3 + k_2/3, t_n+ 2/3h)$

$k_4 = h f (y_n + k_1-k_2+k_3, t_n+ h)$

$y_{n+1} = y_n +1/8 (k_1 + 3k_2 + 3k_3 + k_4)$
###¿Cómo se puede utilizar?
Primeramente se debe ejecutar la celda siguiente para dar inicio a la calculadora de Euler hacia adelante. El segundo paso consiste en ingresa la ecuación despejada para $y'$ al igual que los valores para $y_0$ y $h$.
"""

#@title Calcular con Runge Kutta de cuarto orden por 3/8 de Simpson
try:
  x, y, t = sp.symbols("x y t")
  fun = input('Ingrese la ecuación despejada para y\': ')
  fun_sim= sp.sympify(fun)
  display(Math(sp.latex(fun_sim)))
  y0 = float(input("Ingrese el valor de y0: "))
  h = float(input("Ingrese el valor de h: "))
  t0 = 0
  fun_np = sp.lambdify([y,t], fun_sim, 'numpy')
  k1 = h * (fun_np(y0,t0))
  yn_k2 = y0 + (k1/3)
  tn_h3 = t0 + (h/3)
  resultado_f2 = fun_np(yn_k2, tn_h3)
  k2 = h * resultado_f2
  yn_k3 = y0 +(k1/3) + (k2/3)
  tn_23h = (2/3) * h
  resultado_f3 = fun_np(yn_k3, tn_23h)
  k3 = h * resultado_f3
  yn_k4 = y0 + k1-k2+k3
  tn_h = t0 + h
  resultado_f4 = fun_np(yn_k4, tn_h)
  k4 = h * resultado_f4
  y_n1 = y0 +((1/8)  * (k1 + (3*k2) + (3*k3) + k4))
  print("k1 para y1 : ",k1)
  print("k2 para y1: ",k2)
  print("k3 para y1: ",k3)
  print("k4 para y1: ",k4)
  print('El valor de y1 es: ',y_n1)
  y0 = y_n1
  t0 = t0 + h
  k1 = h * (fun_np(y0,t0))
  yn_k2 = y0 + (k1/3)
  tn_h3 = t0 + (h/3)
  resultado_f2 = fun_np(yn_k2, tn_h3)
  k2 = h * resultado_f2
  yn_k3 = y0 +(k1/3) + (k2/3)
  tn_23h = (2/3) * h
  resultado_f3 = fun_np(yn_k3, tn_23h)
  k3 = h * resultado_f3
  yn_k4 = y0 + k1-k2+k3
  tn_h = t0 + h
  resultado_f4 = fun_np(yn_k4, tn_h)
  k4 = h * resultado_f4
  y_n2 = y0 +((1/8)  * (k1 + (3*k2) + (3*k3) + k4))
  print("k1 para y2 : ",k1)
  print("k2 para y2: ",k2)
  print("k3 para y2: ",k3)
  print("k4 para y2: ",k4)
  print('El valor de y2 es: ',y_n2)
except:
  output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")

"""## Runge Kutta de Orden superior
###¿Cómo funciona?
La mayor exactitud se ve afectada por un excesivo trabajo computacional así como
de complejidad.

$k_1 = h V_n$

$m_1 = h [± a V_n ± b U_n, q_n]$

$k_2 = h (V_n + m_1)$

$m_2 = h [± a (V_n + m_1) ± b (U_n + k_1), q_n+ h]$

$y_{n+1} = y_n + ½ (k_1 + k_2)$

$y´_{n+1} = y´_n + ½ (m_1 + m_2)$

$V_n = y´$ 

$Un = y$ 

$qn = t$


###¿Cómo se puede utilizar?
Al iniciar la calculadora el usuario es responsable de ingresar la función despejada para $y''$ asi como los valores $y'_0$, $y_0$ y $h$, posteriormente se muestra el resultado.

*Para ingresar y', se debe usar v en lugar de y'
"""

#@title Calcular Con Runge Kutta de Orden Superior
try:
  v, x, y, t = sp.symbols("v x y t")
  fun = input('Ingrese la ecuación despejada para y\'\': ')
  fun_sim= sp.sympify(fun)
  display(Math(sp.latex(fun_sim)))
  coeficientes = fun_sim.as_coefficients_dict()
  a = coeficientes.get(v)
  b = coeficientes.get(y)
  if a is None:
      coef_v = fun_sim.coeff(v,1)
      coef_v_bueno = coef_v.coeff(t,1)
      a = coef_v_bueno
  if b is None:
      coef_y = fun_sim.coeff(y,1)
      coef_y_bueno = coef_y.coeff(t,1)
      b = coef_y_bueno
  a = abs(a)
  b = abs(b)
  print(a)
  print(b)
  y0 = float(input("Ingrese el valor de y0: "))
  y0prima = float(input("Ingrese el valor de y\'0: "))
  h = float(input("Ingrese el valor de h: "))
  t0 = 0
  fun_np = sp.lambdify([y,v,t], fun_sim, 'numpy')
  k1 = h * y0prima
  m1 = h * (fun_np(y0,y0prima,t0))
  k2 = h * (y0prima + m1)
  m2 = h * (a*((y0prima+m1) * (t0 + h)) -b*(y0+k1))
  y1 = y0 + (0.5 * (k1+k2))
  y1prima = y0prima + (0.5 * (m1+m2))
  print('k1 para y1: ',k1)
  print('k2 para y1: ',k2)
  print('m1 para y1: ',m1)
  print('m2 para y1: ',m2)
  print('y1 es: ',y1)
  print('y\'1 es: ', y1prima)
  y0 = y1
  y0prima = y1prima
  t0 = t0 + h
  k1 = h * y0prima
  m1 = h * (fun_np(y0,y0prima,t0))
  k2 = h * (y0prima + m1)
  m2 = h * (a*((y0prima+m1) * (t0 + h)) -b*(y0+k1))
  y2 = y0 + (0.5 * (k1+k2))
  y2prima = y0prima + (0.5 * (m1+m2))
  print('k1 para y2: ',k1)
  print('k2 para y2: ',k2)
  print('m1 para y2: ',m1)
  print('m2 para y2: ',m2)
  print('y2 es: ',y2)
  print('y\'2 es: ', y2prima)
except:
  output.clear()
  print("Ha ocurrido un error, revisar el manual de usuario.")